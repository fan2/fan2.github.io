<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Elsewhere]]></title>
  <subtitle><![CDATA[just do IT]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://col.dog/"/>
  <updated>2015-12-13T05:48:20.000Z</updated>
  <id>http://col.dog/</id>
  
  <author>
    <name><![CDATA[Thomas Fan]]></name>
    <email><![CDATA[phunxm@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[vim 学习 002 - vim 键位]]></title>
    <link href="http://col.dog/2015/12/13/vim-tutorials-002-keyboard/"/>
    <id>http://col.dog/2015/12/13/vim-tutorials-002-keyboard/</id>
    <published>2015-12-13T05:46:30.000Z</published>
    <updated>2015-12-13T05:48:20.000Z</updated>
    <content type="html"><![CDATA[<p>本文收集了几张 vim 功能键位布局图。</p>
<a id="more"></a>
<h1 id="给程式设计师的Vim入门图解说明"><a href="http://blog.vgod.tw/2009/12/08/vim-cheat-sheet-for-programmers/?variant=zh-cn" target="_blank" rel="external">给程式设计师的Vim入门图解说明</a></h1><p><img src="http://7xo5uz.com1.z0.glb.clouddn.com/vim-cheat-sheet-full.png" alt="vim-cheat-sheet-full"></p>
<p><img src="http://7xo5uz.com1.z0.glb.clouddn.com/vim-cheat-sheet-diagram.png" alt="vim-cheat-sheet-diagram"></p>
<p><a href="http://www.viemu.com/a_vi_vim_graphical_cheat_sheet_tutorial.html" target="_blank" rel="external">Graphical vi-vim Cheat Sheet and Tutorial</a></p>
<h1 id="Vi/Vim_键盘图"><a href="http://www.cnblogs.com/ldp-web/archive/2011/10/22/2220920.html" target="_blank" rel="external">Vi/Vim 键盘图</a></h1><p><a href="http://km.oa.com/articles/show/68423" target="_blank" rel="external">vim键盘图</a></p>
<p><img src="http://7xo5uz.com1.z0.glb.clouddn.com/vi-vim-cheat-sheet-en.gif" alt="vi-vim-cheat-sheet-en"></p>
<p><img src="http://7xo5uz.com1.z0.glb.clouddn.com/vi-vim-cheat-sheet-cn.png" alt="vi-vim-cheat-sheet-cn"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文收集了几张 vim 功能键位布局图。</p>]]>
    
    </summary>
    
      <category term="vim键位" scheme="http://col.dog/tags/vim%E9%94%AE%E4%BD%8D/"/>
    
      <category term="vim" scheme="http://col.dog/categories/vim/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[vim 学习 001 - vim 参考]]></title>
    <link href="http://col.dog/2015/12/13/vim-tutorials-001-references/"/>
    <id>http://col.dog/2015/12/13/vim-tutorials-001-references/</id>
    <published>2015-12-13T05:39:40.000Z</published>
    <updated>2015-12-13T05:41:49.000Z</updated>
    <content type="html"><![CDATA[<p>本文梳理列举了一些 vim 学习参考链接。</p>
<a id="more"></a>
<h3 id="Mac_OS_X下推荐原生vim"><a href="https://ruby-china.org/topics/4905" target="_blank" rel="external">Mac OS X下推荐原生vim</a></h3><p>Mac OS X 自带的<strong>Terminal</strong> + Mac自带的<strong><a href="http://www.kinnetica.com/2011/05/29/using-screen-on-mac-os-x/" target="_blank" rel="external">screen</a></strong> + 系统内置的<strong>vim</strong>。<br>Terminal是代替 iTerm2，screen是代替 tmux ，vim是代替 MacVim。</p>
<p>至于shell用的是默认的bash(代替zsh,或者fishshell)，screen的配置也是默认的配置, vim配置也是默认的。</p>
<p>关于vim的插件管理，用的是 Vundle.vim。</p>
<h3 id="vi中文乱码问题">vi中文乱码问题</h3><p><a href="http://hi-rain.com/2015/04/02/Vim%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/" target="_blank" rel="external">Vi/Vim中文乱码问题</a><br><a href="http://www.vimer.cn/2009/10/vim%E7%BB%88%E7%AB%AF%E4%B8%8B%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98.html" target="_blank" rel="external">vim终端下中文乱码问题</a><br><a href="http://blog.csdn.net/fuxuejun/article/details/6234512" target="_blank" rel="external">vi 中文显示乱码-问题解决</a><br><a href="http://blog.163.com/little_320/blog/static/38789520091116103325859/" target="_blank" rel="external">linux中vi显示中文乱码的问题</a><br><a href="http://blog.csdn.net/johnnycode/article/details/18298705" target="_blank" rel="external">Vim 中文乱码处理过程</a><br><a href="http://www.diguage.com/archives/26.html" target="_blank" rel="external">彻底解决Git中文乱码问题</a></p>
<h3 id="工具比较">工具比较</h3><p><a href="http://www.vim.org/git.php" target="_blank" rel="external">The Vim repository at GitHub</a><br><a href="https://ruby-china.org/topics/3822?page=1" target="_blank" rel="external">Sublime Text 2和对Vim的研究</a><br><a href="http://my.oschina.net/alphajay/blog/30419" target="_blank" rel="external">Windows下vim方式操作软件+Gvim使用</a><br><a href="http://www.viemu.com/" target="_blank" rel="external">ViEmu - Vi/vim emulation for Visual Studio, Xcode, Word, Outlook &amp; SQL Server</a>  </p>
<h3 id="MacVim">MacVim</h3><p><a href="http://www.jeffzhang.cn/mac-sys-reinstall/" target="_blank" rel="external">MBP系统重装记录</a><br><a href="http://zhouyichu.com/vim/Vim-in-Mac.html" target="_blank" rel="external">Mac中安装Vim7.4</a><br><a href="http://blog.csdn.net/u011542994/article/details/39058779" target="_blank" rel="external">编译升级Mac上的vim到7.4 huge版</a>  </p>
<h3 id="vim-instant-markdown">vim-instant-markdown</h3><p><a href="http://www.cnblogs.com/fsjohnhuang/p/3911541.html" target="_blank" rel="external">Vim杂记：markdown插件</a><br><a href="http://www.codeceo.com/article/vim-markdown-plugins.html" target="_blank" rel="external">Vim 环境下 Markdown 插件推荐</a><br><a href="https://scturtle.me/2012/8/15/vim-instant-markdown-py/" target="_blank" rel="external">vim-instant-markdown</a><br><a href="http://www.opstool.com/article/280" target="_blank" rel="external">使用vim编写markdown文档</a><br><a href="http://blog.chinaunix.net/uid-28769209-id-4148562.html" target="_blank" rel="external">在vim中配置markdown语法高亮</a><br><a href="http://www.vim.org/scripts/script.php?script_id=1334" target="_blank" rel="external">VST : Vim reStructured Text</a>  </p>
<h3 id="配色主题">配色主题</h3><p><a href="http://www.oschina.net/news/32306/10-vim-color-schemes-you-need-to-own?from=20120902" target="_blank" rel="external">10 个你值得拥有的 Vim 配色方案</a><br><a href="http://vim.spf13.com/" target="_blank" rel="external">The Ultimate Vim Distribution</a><br><a href="https://github.com/vgod/vimrc" target="_blank" rel="external">vgod/vimrc</a><br><a href="https://github.com/kaochenlong/eddie-vim" target="_blank" rel="external">kaochenlong/eddie-vim</a>  </p>
<h3 id="vim教程">vim教程</h3><p><a href="http://www.live-in.org/archives/774.html" target="_blank" rel="external">Linux中vi/vim操作</a><br><a href="http://blog.sina.com.cn/s/blog_46dac66f010005kw.html" target="_blank" rel="external">普通人的编辑利器——Vim</a>  </p>
<p><a href="http://blog.jobbole.com/86132/" target="_blank" rel="external">Vim入门教程</a><br><a href="http://blog.csdn.net/shiwei408/article/details/7296462" target="_blank" rel="external">vim 的使用方法</a>  </p>
<p><a href="https://swaroop.wordpress.com/notes/vim_zh-cn-%E6%89%93%E5%AD%97%E6%8A%80%E5%B7%A7/" target="_blank" rel="external">Vim zh-cn:打字技巧</a>  </p>
<p><a href="http://www.cnblogs.com/ovliverlin/articles/1162430.html" target="_blank" rel="external">vi命令详解</a><br><a href="http://linux.chinaunix.net/techdoc/desktop/2009/07/06/1122020.shtml" target="_blank" rel="external">vim使用技巧</a><br><a href="http://www.2maomao.com/blog/wp-content/uploads/vim_tips.txt" target="_blank" rel="external">最佳vim技巧</a><br><a href="https://linuxtoy.org/archives/efficient-editing-with-vim.html" target="_blank" rel="external">高效率地使用VIM</a>  </p>
<h3 id="vim专题">vim专题</h3><p><a href="http://www.vimer.cn/category/vim" target="_blank" rel="external">Vimer的程序世界</a><br><a href="http://blog.csdn.net/shuangde800/article/category/1598575" target="_blank" rel="external">vim高级编辑</a><br><a href="http://dailyvim.tumblr.com/" target="_blank" rel="external">Daily Vim Devotional</a><br><a href="http://liuzhijun.iteye.com/category/270228" target="_blank" rel="external">每日一Vim</a><br><a href="http://easwy.com/blog/archives/advanced-vim-skills-catalog/" target="_blank" rel="external">vi/vim使用进阶</a>  </p>
<h3 id="vim配置IDE">vim配置IDE</h3><p><a href="https://github.com/yangyangwithgnu/use_vim_as_ide" target="_blank" rel="external">像 IDE 一样使用 vim</a><br>谁说Vim不是IDE？<a href="http://www.cnblogs.com/chijianqiang/archive/2012/10/30/vim-1.html" target="_blank" rel="external">（一）</a><a href="http://www.cnblogs.com/chijianqiang/archive/2012/10/31/vim-2.html" target="_blank" rel="external">（二）</a><a href="http://www.cnblogs.com/chijianqiang/archive/2012/11/06/vim-3.html" target="_blank" rel="external">（三）</a><br>配置vim让编程更随意：<a href="http://www.cnblogs.com/ma6174/archive/2011/12/10/2283393.html" target="_blank" rel="external">1</a>  <a href="http://blog.csdn.net/chary8088/article/details/7715383/" target="_blank" rel="external">2</a><br><a href="http://blog.csdn.net/yangyang_gnu/article/details/6642271" target="_blank" rel="external">vim之IDE进化实录</a><br><a href="http://blog.csdn.net/wooin/article/details/1858917" target="_blank" rel="external">手把手教你把Vim改装成一个IDE编程环境(图文)</a>  </p>
<p><a href="http://www.vimer.cn/2009/10/%E6%8A%8Avim%E6%89%93%E9%80%A0%E6%88%90%E4%B8%80%E4%B8%AA%E7%9C%9F%E6%AD%A3%E7%9A%84ide1.html" target="_blank" rel="external">把VIM打造成一个真正的IDE(1)</a><br><a href="http://www.vimer.cn/2009/10/%E6%8A%8Avim%E6%89%93%E9%80%A0%E6%88%90%E4%B8%80%E4%B8%AA%E7%9C%9F%E6%AD%A3%E7%9A%84ide2.html" target="_blank" rel="external">把VIM打造成一个真正的IDE(2)</a><br><a href="http://www.vimer.cn/2009/10/%E6%8A%8Avim%E6%89%93%E9%80%A0%E6%88%90%E4%B8%80%E4%B8%AA%E7%9C%9F%E6%AD%A3%E7%9A%84ide3.html" target="_blank" rel="external">把VIM打造成一个真正的IDE(3)</a>  </p>
<h3 id="vim参考书籍"><a href="http://iccf-holland.org/click5.html" target="_blank" rel="external">vim参考书籍</a></h3><p>A Byte of Vim：《<a href="http://a-byte-of-vim-chinese.readthedocs.org/en/latest/getting-started.html" target="_blank" rel="external">品味Vim</a>》《<a href="http://download.csdn.net/detail/zaiyang2007/3782667" target="_blank" rel="external">简明Vim教程</a>》<br>Practical Vim：《<a href="http://book.douban.com/subject/25869486/" target="_blank" rel="external">Vim实用技巧</a>》《<a href="http://download.csdn.net/download/yahooding/8376925" target="_blank" rel="external">Vim实用技巧</a>》<br>鳥哥的 Linux 私房菜：<a href="http://linux.vbird.org/linux_basic/0310vi.php" target="_blank" rel="external">第九章、vim 程式編輯器</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文梳理列举了一些 vim 学习参考链接。</p>]]>
    
    </summary>
    
      <category term="vim" scheme="http://col.dog/tags/vim/"/>
    
      <category term="vim-IDE" scheme="http://col.dog/tags/vim-IDE/"/>
    
      <category term="vim-主题" scheme="http://col.dog/tags/vim-%E4%B8%BB%E9%A2%98/"/>
    
      <category term="vim-乱码" scheme="http://col.dog/tags/vim-%E4%B9%B1%E7%A0%81/"/>
    
      <category term="vim" scheme="http://col.dog/categories/vim/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[svn 版本控制]]></title>
    <link href="http://col.dog/2015/11/27/svn-version-control/"/>
    <id>http://col.dog/2015/11/27/svn-version-control/</id>
    <published>2015-11-27T06:36:30.000Z</published>
    <updated>2015-12-13T05:17:32.000Z</updated>
    <content type="html"><![CDATA[<p>之前介绍过 <a href="http://blog.csdn.net/phunxm/article/details/40834427" target="_blank" rel="external">subversion 版本控制</a>，本文梳理日常 svn 操作流程，备忘查阅。</p>
<a id="more"></a>
<h2 id="svn_auth-cache">svn auth-cache</h2><p>一般第一次操作过 svn 后（没有指定 <code>--no-auth-cache</code>），会提示确认 auth cache，后面的 svn 操作都会使用缓存的 auth token。</p>
<ol>
<li>linux/Mac 将 auth-cache 保存在 <code>~/.subversion/auth</code> 目录下，可执行 <code>rm -rf ~/.subversion/auth</code> 命令清除。</li>
<li>在 Windows TortoiseSVN 下通过以下步骤可以<a href="http://www.justwinit.cn/post/4512/" target="_blank" rel="external">清除缓存的 svn 认证信息</a>，下次就会要求输入用户名和密码：</li>
</ol>
<blockquote>
<ol>
<li>在任一 Working Copy 上右键，选择 TortoiseSVN–&gt;settings；</li>
<li>在弹出的 TortoiseSVN Settings 页面中选择 <strong><code>Saved Data</code></strong> 选项； </li>
<li>点击 <strong><code>Authentication data</code></strong> 对应的 <strong>Clear</strong> 按钮。</li>
</ol>
</blockquote>
<p>终端 <code>svn checkout --help</code> 或 <code>svn commit --help</code> 可看到 <strong><em>Global options</em></strong> （适用于 svn 大部分 subcommands）中通过 <code>--username</code>/<code>--password</code> 选项可指定用户名和密码：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Global options:&#10;  --username ARG           : specify a username ARG&#10;  --password ARG           : specify a password ARG</span><br></pre></td></tr></table></figure>
<p>如果想临时使用别人的账号 checkout 或 commit 代码，而不使用缓存的 auth token，通过指定 <code>--username</code>/<code>--password</code> 参数进行 svn 操作即可。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">$ svn co URL --username user --password pwd&#10;$ svn ci URL --username user --password pwd</span><br></pre></td></tr></table></figure>
<p>如果可以进入 svn 服务器的话，在 <code>***\conf\authz</code> 中可根据用户名查询 <a href="http://www.cnblogs.com/perfy/p/3508210.html" target="_blank" rel="external">svn 权限</a>。</p>
<h2 id="svn_ignore">svn ignore</h2><p><strong><a href="http://blog.csdn.net/qw503495315/article/details/17454625" target="_blank" rel="external">SmartSVN 设置忽略文件类型设置</a></strong>  </p>
<p>在左侧 Directories Explorer中右击 .git 文件夹选择 ignore。<br>在 Files Explorer 中右击 .gitignore 文件选择 ignore | Ignore Explicitly，则所有目录的同名都将被忽略。<br>右键根目录，在 Properties | Ignore Patterns 中可以删除或编辑 Ignore Patterns。</p>
<p><strong>注意：</strong></p>
<p>unversioned 的文件（目录）需要先添加到 svn 版本库，才能忽略。<br>SmartSVN 已经帮我们将要忽略的 unversioned 文件（目录）添加到版本库，谨防切换到命令行操作时错误提交！</p>
<p><strong>参考：</strong></p>
<blockquote>
<p>《<a href="http://blog.chinaunix.net/uid-10167808-id-83417.html" target="_blank" rel="external">svn 设置忽略文件列表</a>》《<a href="http://my.oschina.net/shelllife/blog/142257" target="_blank" rel="external">SVN 设置忽略文件列表</a>》<br>《<a href="http://huanyue.iteye.com/blog/750108" target="_blank" rel="external">SVN 忽略整个目录</a>》《<a href="http://svnbook.red-bean.com/en/1.8/svn.advanced.props.special.ignore.html" target="_blank" rel="external">Ignoring Unversioned Items</a>》<br>《<a href="http://www.111cn.net/sys/linux/53797.htm" target="_blank" rel="external">SVN忽略文件或文件夹几种方法总结</a>》《<a href="http://yansu.org/2013/04/22/add-svn-ignore-file.html" target="_blank" rel="external">给SVN控制的项目添加忽略文件/文件夹</a>》  </p>
</blockquote>
<h2 id="svn_info">svn info</h2><p><code>svn info</code> 命令可以查看当前工作目录（Working Copy）的版本信息。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#8658;  svn info --help&#10;info: Display information about a local or remote item.&#10;usage: info [TARGET[@REV]...]</span><br></pre></td></tr></table></figure>
<p>通过 <code>--show-item</code> 指定选项，可以打印指定项。</p>
<pre><code>kind                  <span class="operator">the</span> kind <span class="operator">of</span> TARGET
url                   <span class="operator">the</span> <span class="built_in">URL</span> <span class="operator">of</span> TARGET <span class="operator">in</span> <span class="operator">the</span> repository
<span class="built_in">relative</span>-url          <span class="operator">the</span> repository-<span class="built_in">relative</span> <span class="built_in">URL</span>
repos-root-url        <span class="operator">the</span> repository root <span class="built_in">URL</span>
repos-<span class="built_in">uuid</span>            <span class="operator">the</span> repository UUID
revision              <span class="operator">the</span> revision <span class="operator">of</span> TARGET (defaults <span class="built_in">to</span> BASE
                      <span class="keyword">for</span> working copy paths <span class="operator">and</span> HEAD <span class="keyword">for</span> URLs)
<span class="keyword">last</span>-changed-revision <span class="operator">the</span> most recent revision <span class="operator">in</span> which TARGET
                      was changed
<span class="keyword">last</span>-changed-<span class="built_in">date</span>     <span class="operator">the</span> <span class="built_in">date</span> <span class="operator">of</span> <span class="operator">the</span> <span class="keyword">last</span>-changed revision
<span class="keyword">last</span>-changed-author   <span class="operator">the</span> author <span class="operator">of</span> <span class="operator">the</span> <span class="keyword">last</span>-changed revision
wc-root               <span class="operator">the</span> root <span class="operator">of</span> TARGET<span class="string">'s working copy</span>
</code></pre><p>以下示范 svn checkout Reachability 工程的 info：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">faner<span class="annotation">@MBP</span>-<span class="string">FAN:</span><span class="regexp">~/Projects/</span>git/Reachability|</span><br><span class="line">⇒  svn info</span><br><span class="line"><span class="string">Path:</span> .</span><br><span class="line">Working Copy Root <span class="string">Path:</span> <span class="regexp">/Users/</span>faner<span class="regexp">/Projects/</span>git/Reachability</span><br><span class="line"><span class="string">URL:</span> <span class="string">https:</span><span class="comment">//github.com/tonymillion/Reachability</span></span><br><span class="line">Relative <span class="string">URL:</span> ^/</span><br><span class="line">Repository <span class="string">Root:</span> <span class="string">https:</span><span class="comment">//github.com/tonymillion/Reachability</span></span><br><span class="line">Repository <span class="string">UUID:</span> <span class="number">97</span>ad356b-<span class="number">402</span>e-f69d-e5e9-ce57b7db7bff</span><br><span class="line"><span class="string">Revision:</span> <span class="number">89</span></span><br><span class="line">Node <span class="string">Kind:</span> directory</span><br><span class="line"><span class="string">Schedule:</span> normal</span><br><span class="line">Last Changed <span class="string">Author:</span> tony.million</span><br><span class="line">Last Changed <span class="string">Rev:</span> <span class="number">89</span></span><br><span class="line">Last Changed <span class="string">Date:</span> <span class="number">2015</span>-<span class="number">09</span>-<span class="number">12</span> <span class="number">00</span>:<span class="number">42</span>:<span class="number">38</span> +<span class="number">0800</span> (六, <span class="number">12</span>  <span class="number">9</span> <span class="number">2015</span>)</span><br></pre></td></tr></table></figure>
<h2 id="svn_status">svn status</h2><p><a href="http://blog.linuxphp.org/archives/1377/" target="_blank" rel="external">status</a> (stat, st): 显示工作副本（Working Copy）中的目录与文件状态。</p>
<p>执行 <code>svn status</code> 或 <code>svn up</code>（<code>svn merge</code>）等命令时，出现在首位置的标志含义如下表：</p>
<table>
<thead>
<tr>
<th>标志</th>
<th>状态</th>
</tr>
</thead>
<tbody>
<tr>
<td>“ ”</td>
<td>无修改</td>
</tr>
<tr>
<td>A</td>
<td>增加（Added）</td>
</tr>
<tr>
<td>D</td>
<td>删除（Deleted）</td>
</tr>
<tr>
<td>I</td>
<td>忽略（Ignored）</td>
</tr>
<tr>
<td>M</td>
<td>改变（Modified）</td>
</tr>
<tr>
<td><a href="http://stackoverflow.com/questions/10180700/what-does-mm-means-when-i-run-a-svn-diff" target="_blank" rel="external">MM</a></td>
<td>文件的属性和内容都被改变了</td>
</tr>
<tr>
<td>U</td>
<td>表示更新（Updated）</td>
</tr>
<tr>
<td>UU</td>
<td>文件的属性和内容都更新了</td>
</tr>
<tr>
<td>C</td>
<td>冲突（Conflicted）</td>
</tr>
<tr>
<td>G</td>
<td>合并（Merged）</td>
</tr>
<tr>
<td>E</td>
<td>已经存在（Existed）</td>
</tr>
<tr>
<td>R</td>
<td>替换（Replaced）</td>
</tr>
<tr>
<td>X</td>
<td>未纳入版本控制的目录，被外部引用的目录所创建</td>
</tr>
<tr>
<td>?</td>
<td>未纳入版本控制，需要执行 <code>svn add</code></td>
</tr>
<tr>
<td>!</td>
<td>该项目已遗失(被非 svn 命令删除)或不完整</td>
</tr>
<tr>
<td>~</td>
<td>版本控制下的项目与其它类型的项目重名</td>
</tr>
</tbody>
</table>
<p>执行 <code>svn status</code> 没有指定选项参数时，默认只显示本地修改条目的摘要信息（<code>-q</code>）。   也可以指定 <code>-v</code> （<code>--verbose</code>）选项，显示每个条目的完整版本信息。</p>
<h2 id="svn_add">svn add</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">faner@MBP-FAN:~|&#8658;  svn add --help&#10;add: Put files and directories under version control, scheduling them for addition to repository.&#10;They will be added in next commit.&#10;&#10;usage: add PATH...</span><br></pre></td></tr></table></figure>
<p><code>svn add</code> 支持添加单个<strong>文件</strong>到版本控制，同时亦支持添加<strong>文件夹</strong>，它将自动将文件夹下未纳入版本控制的文件添加到 svn 版本控制。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">$ pwd&#10;~/Projects/branch/Classes/module/FAUI/FAView&#10;$ svn add FAViewBottom.h FAViewBottom.m&#10;A         FAViewBottom.h&#10;A         FAViewBottom.m</span><br></pre></td></tr></table></figure>
<p>执行完 <code>svn add</code> 将文件（夹）添加到本地 WC（Working Copy）之后，还需要执行 commit 命令提交到服务器：</p>
<blockquote>
<p>$ svn commit -m ‘add FAViewBottom’</p>
</blockquote>
<h2 id="svn_commit">svn commit</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">faner@MBP-FAN:~|&#8658;  svn commit --help&#10;commit (ci): Send changes from your working copy to the repository.&#10;usage: commit [PATH...]&#10;&#10;  A log message must be provided, but it can be empty.  If it is not given by a --message or --file option, an editor will be started.&#10;&#10;Valid options:&#10;  -q [--quiet]             : print nothing, or only summary information&#10;  --depth ARG              : limit operation by depth ARG (&#39;empty&#39;, &#39;files&#39;, &#39;immediates&#39;, or &#39;infinity&#39;)&#10;  -m [--message] ARG       : specify log message ARG&#10;  -F [--file] ARG          : read log message from file ARG&#10;  --editor-cmd ARG         : use ARG as external editor</span><br></pre></td></tr></table></figure>
<p>执行 <code>svn checkout</code> 将代码下载到本地进行增删改后，如果需要上库同步修改成果，可执行 <code>svn commit</code> 命令提交修改。</p>
<p><code>svn commit</code> 支持提交单个<strong>文件</strong>，同时亦支持提交<strong>文件夹</strong>，它将自动收集提交文件夹下有改动的文件。</p>
<p>参数 <code>-m [--message]</code> 指定此次提交的日志，或通过 <code>-F [--file]</code> 选项指定从文件中读取日志。</p>
<blockquote>
<p>$ svn ci test.m -m “This is log message”<br>$ svn ci test.m -F log.txt</p>
</blockquote>
<p><code>svn commit -m</code>提交代码时，通常只能写一行日志信息。如果想要书写<strong>多行日志</strong>，可以通过 <code>$&#39; &#39;</code> 格式支持换行。<br><code>$&#39; &#39;</code>：单引号引用的内容中支持使用转义字符 <code>\n</code> 进行换行，可 echo 查看效果：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">$ echo $&#39;This is the first line\nThis is the second line&#39;&#10;This is the first line&#10;This is the second line</span><br></pre></td></tr></table></figure>
<blockquote>
<p>$ svn ci test.m -m $’This is the first line\nThis is the second line’</p>
</blockquote>
<p><code>svn commit</code> 提交代码时，可通过 <code>-editor-cmd</code> 参数选项指定 log 编辑器。例如，以下提交代码时将打开 <code>vim</code> 撰写日志（<code>:wq</code> 保存退出提交）。</p>
<blockquote>
<p>$ svn ci test.m –editor-cmd=vim</p>
</blockquote>
<h2 id="svn_delete">svn delete</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">faner@MBP-FAN:~|&#8658;  svn delete --help&#10;delete (del, remove, rm): Remove files and directories from version control.&#10;usage: 1. delete PATH...&#10;       2. delete URL...</span><br></pre></td></tr></table></figure>
<p><code>svn delete</code> 支持将单个<strong>文件</strong>移除版本控制，同时亦支持删除<strong>文件夹</strong>，它将自动递归将文件夹下的文件解除版本控制。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">$ pwd&#10;~/Projects/branch/Classes/module/FAUI/FAView&#10;$ svn delete FAViewBottom.h FAViewBottom.m&#10;D         FAViewBottom.h&#10;D         FAViewBottom.m</span><br></pre></td></tr></table></figure>
<p>执行完 <code>svn delete</code> 将文件（夹）从到本地 WC（Working Copy）中解除版本控制之后，还需要执行 commit 命令提交到服务器：</p>
<blockquote>
<p>$ svn commit -m ‘delete FAViewBottom’</p>
</blockquote>
<h2 id="svn_log"><a href="http://www.nc21.cn/ncnet/article.asp?nc=15-12-147-0-6735.xhtml" target="_blank" rel="external">svn log</a></h2><ul>
<li>显示当前 svn 工程的 log（till base of the working copy）</li>
</ul>
<blockquote>
<p>$ svn log</p>
</blockquote>
<ul>
<li>显示当前 svn 工程中指定文件的 log</li>
</ul>
<blockquote>
<p>$ svn log FACategoryTableView.m</p>
</blockquote>
<ul>
<li>显示当前 svn 工程中指定文件某个 revision 的 log</li>
</ul>
<blockquote>
<p>$ svn log FACategoryTableView.m@v #v必须≤base的版本号</p>
</blockquote>
<ul>
<li>显示服务器上某个文件的 log（HEAD will be first looked up：@HEAD means range HEAD:1）</li>
</ul>
<blockquote>
<p>$ svn log path/to/your-svn-repo/directory/file.c</p>
</blockquote>
<ul>
<li>显示服务器上某个文件某个 revision 以及之前的 log（REV will be first looked up：@REV=REV:1）</li>
</ul>
<blockquote>
<p>$ svn log path/to/your-svn-repo/directory/file.c@113629</p>
</blockquote>
<ul>
<li>显示服务器上某个文件在某几个 revision 之间（<code>-r</code>（<code>--revision</code>）选项）的变更日志</li>
</ul>
<blockquote>
<p>$ svn log path/to/your-svn-repo/directory/file.c -r 113714:113629</p>
</blockquote>
<ul>
<li>查看最近 N 条log，<code>-l</code> （<code>--limit</code>）选项指定 limitation，后面的 N 为数字</li>
</ul>
<blockquote>
<p>$ svn log -l N</p>
<blockquote>
<p>$ svn log -l 3</p>
</blockquote>
</blockquote>
<ul>
<li>日志重定向到文件</li>
</ul>
<blockquote>
<p>$ svn log -r 14 &gt; svn.log</p>
</blockquote>
<p><strong>注意</strong>:</p>
<blockquote>
<p>当你执行 svn commit 提交后，svn log 并不能看到刚才提交的版本日志。<br>需要执行 <strong>update</strong> 以后，才能看到最新的 log，因为 commit 和 update 是独立的操作，commit 并不更新本地版本信息！</p>
</blockquote>
<h2 id="svn_revert">svn revert</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#8658;  svn revert --help&#10;revert: Restore pristine working copy state (undo local changes).&#10;usage: revert PATH...&#10;&#10;  Revert changes in the working copy at or within PATH, and remove&#10;  conflict markers as well, if any.&#10;&#10;  This subcommand does not revert already committed changes.&#10;  For information about undoing already committed changes, search&#10;  the output of &#39;svn help merge&#39; for &#39;undo&#39;.</span><br></pre></td></tr></table></figure>
<ol>
<li><p>恢复文件：</p>
<blockquote>
<p>svn revert test.mm</p>
</blockquote>
</li>
<li><p>恢复文件夹（–recursive）：</p>
<blockquote>
<p>svn revert -R .</p>
</blockquote>
</li>
<li><p><strong>Roll back (Undo)</strong></p>
</li>
</ol>
<p><code>svn revert</code> 没有 <code>-r</code> 选项来支持回滚到指定版本号，只能通过间接方式手动实现回滚。</p>
<blockquote>
<p>TortoiseSVN → Show log → 选中需要回滚的版本 → 右键 → Export（命令行 <code>svn checkout -r</code>）</p>
</blockquote>
<p>通过以上操作，直接 export 一个你需要的版本，然后用 export 的版本覆盖最新版本，commit 即实现了等效的回滚。</p>
<h2 id="svn_diff">svn diff</h2><p><code>svn diff</code> 命令用于查看当前目录下的改动（依次 svn diff 各个有改动的文件的差异）：</p>
<pre><code><span class="comment"><figure class="highlight"><table><tr><td class="code"><pre><span class="line">$ svn diff -r newversion:oldversion path&#10;$ svn diff -r r1:(r1-1)  (filename)</span><br></pre></td></tr></table></figure></span>
</code></pre><ol>
<li><p>不使用任何参数时，svn diff 将会比较 working copy 与缓存在 <code>.svn</code> 中的“原始”拷贝：</p>
<blockquote>
<p>$ svn diff</p>
</blockquote>
</li>
<li><p>只传递一个 <code>--revision</code>（-r）参数时，工作拷贝将会与指定的版本比较：</p>
<blockquote>
<p>$ svn diff -r 108249 FACategoryTableView.m</p>
</blockquote>
<p> 默认追加:HEAD!</p>
</li>
<li><p>通过 <code>--revision</code>（-r）传递两个通过冒号分开的版本号，会对这两个版本进行比较：</p>
<blockquote>
<p>$ svn diff -r 108314:108249 FACategoryTableView.m</p>
</blockquote>
</li>
<li><p>diff 不显示各个文件的详细差异比较，<strong>只显示增删改概要</strong>，以便作为commit参考：</p>
 <figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">$ svn diff <span class="comment">--summarize</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="svn_patch（打补丁）">svn patch（打补丁）</h2><h3 id="TortoiseSVN（windows）">TortoiseSVN（windows）</h3><ol>
<li>项目右键 <code>TortoiseSVN|Create patch...</code></li>
<li>选择改动要打 patch 的文件，将会生成 <code>*.patch</code>，同时弹出 TortoiseUDiff 显示 diff 。</li>
<li>将 <code>*.patch</code> 拷贝到其他分支同级别目录下，右键 <code>TortoiseSVN|Apply patch...</code>，选择 <code>Patch selected item</code>，将会自动根据补丁中的 Index 路径合并 diff 到对应文件。</li>
</ol>
<blockquote>
<p><a href="http://blog.csdn.net/gaojinshan/article/details/7856550" target="_blank" rel="external">用 Tortoise SVN 抽取补丁包（patch）</a><br><a href="http://www.uml.org.cn/pzgl/200903276.asp" target="_blank" rel="external">如何让 TortoiseSVN 仅导出新增或修改过(变更过)的文件</a></p>
</blockquote>
<h3 id="命令行（Mac_OS_X）">命令行（Mac OS X）</h3><ol>
<li><p>执行 <code>svn diff --summarize</code> 查看有哪些文件改动</p>
 <figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#8658;  svn diff -h&#10;diff (di): Display local changes or differences between two revisions or paths.&#10;&#10;&#8658;  svn diff --summarize&#10;M       path1/to/test.mm</span><br></pre></td></tr></table></figure>
</li>
<li><p>对欲打补丁的改动文件执行 <code>svn diff</code> 并重定向保存为补丁（<code>*.diff</code> 或 <code>*.patch</code>），执行 <code>cat</code> 或 <code>vim</code> 可查看 diff 详情：</p>
 <figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">⇒  svn diff <span class="keyword">test</span>.mm &gt; <span class="keyword">test</span>.diff</span><br><span class="line"></span><br><span class="line">⇒  <span class="keyword">cat</span> <span class="keyword">test</span>.diff</span><br></pre></td></tr></table></figure>
</li>
<li><p>将补丁文件（test.diff）拷贝到其他分支同级别目录下，执行 <code>svn patch</code> 命令 将会自动根据补丁中的 Index 路径合并 diff 到对应文件。</p>
 <figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">⇒  svn patch --help</span><br><span class="line">patch: Apply <span class="tag">a</span> patch to <span class="tag">a</span> working copy.</span><br><span class="line">usage: patch PATCHFILE [WCPATH]</span><br><span class="line"></span><br><span class="line">⇒  svn patch test<span class="class">.diff</span> </span><br><span class="line">U         path2/to/test.mm</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="svn_merge（同步_&amp;_合流）">svn merge（同步 &amp; 合流）</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#8658;  svn merge --help&#10;merge: Merge changes into a working copy.&#10;usage: 1. merge SOURCE[@REV] [TARGET_WCPATH]&#10;          (the &#39;complete&#39; merge)&#10;       2. merge [-c M[,N...] | -r N:M ...] SOURCE[@REV] [TARGET_WCPATH]&#10;          (the &#39;cherry-pick&#39; merge)&#10;       3. merge SOURCE1[@REV1] SOURCE2[@REV2] [TARGET_WCPATH]&#10;          (the &#39;2-URL&#39; merge)</span><br></pre></td></tr></table></figure>
<h3 id="master2branch（merge_to_sync/rebase）">master2branch（merge to sync/rebase）</h3><p>同步最新主干到分支（同步基线）：TortoiseSVN 基于 branch working copy 右键 merge</p>
<ul>
<li>URL to merge from：填写主干 master 的 svn url；</li>
<li><p>Revision range to merge：选择 <strong><code>specific range</code></strong>。</p>
<p>  选择上次 rebase 的 rev（112603）作为起始点，最新的 rev 作为结束点。</p>
<ul>
<li>112608（one rev）</li>
<li>112608,112630（two rev）</li>
<li>112608-112630（range through）</li>
<li>1-HEAD（rebase 到最新，自动识别起始）</li>
</ul>
</li>
<li><p>Test merge 为 dry-run 可预览合并结果；Merge 执行合并操作。</p>
</li>
<li>如果提示有冲突，本地手工解决。</li>
<li>commit 提交本地分支 WC 的 rebase 合并结果。</li>
</ul>
<p><strong>同步结果：</strong></p>
<blockquote>
<p>Merging revisions 1-HEAD of  <code>http://yoursvnserver/basic/basic_your_rep/your_proj/trunk/master</code> into <code>path/to/your/local-branch-working-copy</code><br>Merging <code>rX</code> through <code>rY</code></p>
</blockquote>
<p><strong>svn 命令行：</strong></p>
<blockquote>
<p>cd <code>path/to/your/local-branch-working-copy</code><br>svn merge <code>http://yoursvnserver/basic/basic_your_rep/your_proj/trunk/master</code> .</p>
</blockquote>
<p><strong>日志：</strong></p>
<blockquote>
<p>— Merging differences between repository URLs into ‘.’:</p>
</blockquote>
<h3 id="branch2master（merge_to_reintegrate）">branch2master（merge to reintegrate）</h3><p>合并开发分支到主干（合流）：TortoiseSVN 基于 master working copy 右键 merge</p>
<p>branch2master（基本步骤同master2branch）</p>
<ul>
<li>URL to merge from：填写分支 branch 的 svn url；</li>
<li>Revision range to merge：选择 <strong><code>all revisions</code></strong>。</li>
<li>Merge options 中勾选 “Do reintegrate instead of automatic merge（old style）”，相当于旧版本的 Merge type：”Reintegrate a branch”。</li>
<li>Test merge 为 dry-run 可预览合并结果；Merge 执行合并操作。</li>
<li>如果提示有冲突，本地手工解决。注意 <strong>revert</strong> 本地未做修改的 property only 的 change/modification。</li>
<li>commit 提交本地主干 WC 的 rebase 合并结果。</li>
</ul>
<p><strong>合流结果：</strong></p>
<blockquote>
<p>Merging revisions of 1-HEAD of<br><code>http://yoursvnserver/basic/basic_your_rep/your_proj/branches/BusinessFlow/branch</code> into <code>path/to/your/local-master-working-copy</code><br>Merging <code>rX</code> through <code>rY</code></p>
</blockquote>
<p><strong>svn 命令行：</strong></p>
<blockquote>
<p>cd <code>path/to/your/local-master-working-copy</code><br>svn merge –reintegrate  <code>http://yoursvnserver/basic/basic_your_rep/your_proj/branches/BusinessFlow/branch</code> .</p>
</blockquote>
<p><strong>日志：</strong></p>
<blockquote>
<p>— Merging differences between repository URLs into ‘.’:</p>
</blockquote>
<h3 id="Merge_two_different_trees">Merge two different trees</h3><p>Tree merge</p>
<ul>
<li><p>From：（start URL and revision of the range to merge）</p>
<p>  “起始URL和版本”一般情况下必须是开发分支创建的起始版本。<br>  主干的 URL、版本为 HEAD</p>
</li>
<li><p>To：（end URL and revision of the range to merge）</p>
<p>  “结束的URL和版本”是此次操作的最终标准。<br>  分支的 URL、版本为 HEAD</p>
</li>
<li><p>Working Copy</p>
<p>  From：（start URL and revision of the range to merge）</p>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前介绍过 <a href="http://blog.csdn.net/phunxm/article/details/40834427">subversion 版本控制</a>，本文梳理日常 svn 操作流程，备忘查阅。</p>]]>
    
    </summary>
    
      <category term="svn-diff" scheme="http://col.dog/tags/svn-diff/"/>
    
      <category term="svn-info" scheme="http://col.dog/tags/svn-info/"/>
    
      <category term="svn-log" scheme="http://col.dog/tags/svn-log/"/>
    
      <category term="svn-merge" scheme="http://col.dog/tags/svn-merge/"/>
    
      <category term="svn-patch" scheme="http://col.dog/tags/svn-patch/"/>
    
      <category term="svn-revert" scheme="http://col.dog/tags/svn-revert/"/>
    
      <category term="svn" scheme="http://col.dog/categories/svn/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Mac 下的软件安装 —— 从 pkg,dmg 到 brew,cask]]></title>
    <link href="http://col.dog/2015/11/22/homebrew/"/>
    <id>http://col.dog/2015/11/22/homebrew/</id>
    <published>2015-11-22T07:05:00.000Z</published>
    <updated>2015-12-08T11:29:02.000Z</updated>
    <content type="html"><![CDATA[<p>本文前驱铺垫梳理了从 linux 源码安装软件到 DPKG/RPM 软件包管理机制，阐述了 *UNX 平台的软件安装包管理机制的演变和现代化。<br>后半部分介绍了 Mac 下的软件安装包格式 —— pkg &amp; dmg，以及软件包管理工具 —— brew 及 brew-cask，并梳理日常 Command Usage。</p>
<a id="more"></a>
<h2 id="linux_软件的安装与管理"><a href="http://blog.chinaunix.net/uid-509190-id-3056219.html" target="_blank" rel="external">linux 软件的安装与管理</a></h2><p><a href="https://github.com/torvalds/linux" target="_blank" rel="external">linux</a> 是一套免费使用和自由传播的基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的开源的类 Unix 操作系统。<br>由于 linux 操作系统开放源代码，因而在其上安装的大部分也都是开源软件。开源软件的开发者往往仅需在开源代码托管平台上发布一份源码包，用户即可自由下载源码包到本地，基于源码包编译安装软件。这倒是非常符合 C 语言的设计哲学：一次编写，到处编译。</p>
<h3 id="基于源码安装软件"><a href="http://www.cnblogs.com/huangfenghit/archive/2011/02/17/1957057.html" target="_blank" rel="external">基于源码安装软件</a></h3><p>基于源码安装软件一般由以下几个步骤组成：</p>
<ul>
<li>下载解压源码</li>
<li>阅读 README、INSTALL 等说明文档，这一步至关重要</li>
<li>分析安装平台环境（ifconfigure）</li>
<li>编译安装软件（make，make install）</li>
</ul>
<p>基于源代码安装软件的好处是：用户可以自由配置编译选项，按需编译实现功能定制，极大地满足<strong><a href="http://www.zhihu.com/question/21949923" target="_blank" rel="external">个性化需求</a></strong>。此外，用户还可以自己选择安装路径，方便管理。卸载软件也很方便，只需删除对应的安装目录即可。<br>但是，配置、编译命令需要了解操作系统本身，并且依赖开源项目所使用的编程语言对应的工具链。为了使用一个应用软件，用户需要熟悉 linux 系统的文件组织架构和一堆  Shell 交互命令，还得解决编译过程中可能涉及到的繁杂的依赖关系。一定的英文水平也是必需的，关键是要有折腾不息的精神和顽强的动手能力！<br>English、OS、Linux、命令行交互方式、…，这些令人望而却步的门槛足以将普通用户拒之门外。安装后，你可能都不知道<a href="http://www.linuxidc.com/Linux/2009-11/22842.htm" target="_blank" rel="external">安装到哪里去了</a>；甚至离开了 Windows 桌面，你都不知道从哪里启动软件。我依稀地记得刚接触 linux 那会儿，为了能在 linux 上播放个视频文件，废了老大劲才安装好一个 <a href="http://blog.pfan.cn/xman/41044.html" target="_blank" rel="external">MPlayer</a>。当时就森森地觉得 linux 真不是一般人能折腾得起，尽管现在已经折腾惯了，但依然觉得费脑伤神。<br>作为一个曾经的<a href="http://www.tinylab.org/why-computer-students-learn-linux-open-source-technologies/" target="_blank" rel="external">计算机旁系学生</a>（自动化，别名计算机控制）、现在的半职业化软件攻城狮（涉猎甚广，浅显浮泛）和伪自由软件追崇者（用过盗版，不懂破解，从无贡献），因为工作关系经常穿梭于 Windows 和 Mac OS X 之间（游离其间，无所专精），不折腾下 Linux/Unix 都觉得没法混 github。<br>尽管对于 vim 键盘型用户（估计基本都是程序员吧），很喜欢那种游离于指尖的”自由感”，但对于普通鼠标型 Windows 用户，<a href="http://www.zhihu.com/question/20117703" target="_blank" rel="external">若无力驾驭，自由便是负担。</a>  </p>
<blockquote>
<p>只有开发人员才需要学习一个操作系统本身，用户只需要学习操作系统里面的每个“应用程序”怎么使用。<br>—— Linus Torvalds</p>
</blockquote>
<h3 id="DPKG_/_RPM">DPKG / RPM</h3><p>伴随着 linux 的发展普及，linux 开发商开始在固定的硬件平台与操作系统上将要安装或升级的软件<strong>编译好</strong>，然后将这个软件的所有相关文件<strong>打包</strong>成一个特殊格式的文件。在这个软件内，还包含了预先检测系统与依赖软件（或动态链接库）的脚本，并提供记载该软件提供的所有文件信息等，最终将这个软件发布。<br>客户端取得软件后，只要通过特定的命令来安装，那么该软件就会按照内部的脚本来检测相关的前驱软件是否存在。若安装的环境和条件符合要求，则开始安装。软件在安装完成后，还会将信息写入软件管理机制中，以便完成未来的升级、删除（反安装）等操作。</p>
<p>目前，在 Linux 界最常见的软件安装方式有两种：</p>
<ol>
<li><p>DPKG</p>
<ul>
<li><strong>DPKG</strong>（Debian Packager）是由 <a href="https://www.debian.org/" target="_blank" rel="external">Debian Linux</a> 社区所开发出来的，著名的 <code>package</code> 概念由此被引入到 GNU/Linux 系统中。</li>
<li>通过 DPKG 机制，Debian 提供的软件就能够简单安装起来，同时还能提供安装后的软件信息。派生于 Debian 的其他 <a href="https://zh.wikipedia.org/wiki/Linux%E5%8F%91%E8%A1%8C%E7%89%88%E5%88%97%E8%A1%A8" target="_blank" rel="external">Linux</a> <a href="http://distrowatch.com/" target="_blank" rel="external">Distributions</a> 大多使用 dpkg 机制来管理软件，包括 <a href="http://distrowatch.com/table.php?distribution=b2d" target="_blank" rel="external">B2D</a>、<a href="http://www.ubuntu.com/global" target="_blank" rel="external">Ubuntu</a>、<a href="http://linuxmint.com/" target="_blank" rel="external">Linux Mint</a> 等。</li>
<li>Debian 为解决软件包更新问题，引入了 <strong>APT</strong>（Advanced Package Tool）<a href="http://www.cnblogs.com/kulin/archive/2012/07/31/2616490.html" target="_blank" rel="external">在线升级机制</a>，并在 <code>/etc/apt/sources.list</code> 文件列出了可获得软件包的镜像站点地址。<ul>
<li>APT 由几个名字以 <code>apt-</code> 打头的程序组成，apt-get、apt-cache 和 apt-cdrom 是处理软件包的命令行工具。</li>
<li>apt 作为 dpkg 的前端工具，自动管理关联文件和维护已有配置文件，拥有出色的解决软件依赖问题的能力。</li>
</ul>
</li>
</ul>
</li>
<li><p>RPM</p>
<ul>
<li><strong>RPM</strong>（RedHat Package Manager）是由 Red Hat 公司所开发出来的软件包管理程序。除了可以用来安装（-i）外，还可以进行查询（-q）、验证（-V）、更新（-U）、删除（-e）等操作，这些功能选项让软件的管理更加方便。包括 <a href="https://getfedora.org/" target="_blank" rel="external">Fedora</a>、<a href="https://www.centos.org/" target="_blank" rel="external">CenterOS</a>、<a href="https://www.suse.com/" target="_blank" rel="external">SUSE</a>/<a href="https://www.opensuse.org/" target="_blank" rel="external">openSUSE</a> 等知名的 linux 发行版本都使用 RPM 作为软件安装的管理机制。</li>
<li>RPM 包的封装格式一般有两种，分别是 <strong>RPM</strong> 和 <strong>SRPM</strong>。RPM 格式的文件 <code>xxx.rpm</code> 内含已经经过编译的二进制包和配置文件等数据。SRPM（Source RPM）对应的 RPM 文件类似于 <code>xxx.src.rpm</code> 格式，它包含了源码文件和一些编译指定的参数文件。因而，在使用的时候，需要先以 RPM 管理的方式编译为 RPM 文件(<a href="http://www.centoscn.com/CentOS/2014/1029/4015.html" target="_blank" rel="external">rpmbuild</a>，再将编译完成的 RPM 文件安装到 Linux 系统中。</li>
<li>RPM 无法自动解决软件的依赖关系，使用与 APT 对应的 <strong><a href="http://www.cnblogs.com/mchina/archive/2013/01/04/2842275.html" target="_blank" rel="external">YUM</a></strong> (<a href="http://www.fixstars.com/en/technologies/linux/" target="_blank" rel="external">Yellowdog</a> Updater Modified) 机制可以<strong>解决属性依赖问题</strong>。<strong><a href="http://www.cnblogs.com/chuncn/archive/2010/10/17/1853915.html" target="_blank" rel="external">YUM</a></strong> 作为基于 RPM 的 Shell 前端软件包管理器，主要用于自动升级、安装/移除 RPM 软件包。它能够自动查找并解决 RPM 包之间的依赖关系，而无需管理员逐个手工的去安装每一个 RPM 包。</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>Distribution 代表</th>
<th>包管理机制</th>
<th>使用命令</th>
<th>在线升级机制(命令)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Red Hat / Fedora</td>
<td>RPM</td>
<td>rpm，rpmbuild</td>
<td>YUM(yum)</td>
</tr>
<tr>
<td>Debian / Ubuntu</td>
<td>DPKG</td>
<td>dpkg</td>
<td>APT(apt-get)</td>
</tr>
</tbody>
</table>
<p>在 <a href="http://mitblog.pixnet.net/blog/post/41037058-10-%E5%A5%97-linux-%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1%E7%9A%84%E6%AF%94%E8%BC%83%E3%80%81ubuntu-vs-fedora-vs-cen" target="_blank" rel="external">linux 众多发行版</a>中，ubuntu 占领桌面，RHEL/<a href="http://www.g-loaded.eu/2009/10/05/fedora-server-vs-centos/" target="_blank" rel="external">CentOS</a> 占领服务器，比较小众的 <strong><a href="https://www.gentoo.org/" target="_blank" rel="external">Gentoo</a></strong> 采用独特的 <strong><a href="https://zh.wikipedia.org/wiki/Portage" target="_blank" rel="external">Portage</a></strong> 包管理系统。Gentoo 的软件树称为 Portage，对应的包管理器是 emerge，包元文件称为 ebuild。<br>Gentoo 是个强调能自由选择的分发版，它使用源码来做包管理的方式。由于能自己编译及调整源码依赖等选项，而获得至高的自定义性及优化的软件，在源码包也有相当多新旧版本的选择，因此吸引了许多狂热爱好者以及专业人士。</p>
<h4 id="RPM_/_SRPM"><a href="http://linux.vbird.org/linux_basic/0520rpm_and_srpm.php" target="_blank" rel="external">RPM / SRPM</a></h4><p>RPM 软件包命名规范：<code>name-version-release.arch.rpm</code>。<br>其中，<code>version</code> 表示系统的发行版，如 fc18、el6 表明这个软件包是在 Fedora 18、RHEL 6.x / CentOS 6.x 下使用的；<code>arch</code> 表示硬件平台，常见的有 i386、x86_64 等。</p>
<p><strong><code>rp-pppoe-3.1-5.i386.rpm</code></strong> 是一个典型的 RPM 安装包，它由几个部分构成：</p>
<ul>
<li><code>rp-pppoe</code>：名称</li>
<li><code>3.1</code>：版本信息</li>
<li><code>5</code>：发布次数</li>
<li><code>.i386</code>：适合的硬件平台</li>
<li><code>.rpm</code>：扩展名</li>
</ul>
<p>RPM 文件必须要在相同的 linux 环境才能安装，而 SRPM 是源代码格式。我们可以通过修改 SRAM 内的参数，按需编译生成适合我们 linux 环境的 RPM 文件，而不必与原作者打包的 Linux 环境相同。<br>通常一个软件在发布的时候，都会同时释放出该软件的 RPM 与 SRPM。</p>
<table>
<thead>
<tr>
<th>文件格式</th>
<th>扩展名格式</th>
<th>直接安装与否</th>
<th>内含程序类型</th>
<th>可否修改参数并编译</th>
</tr>
</thead>
<tbody>
<tr>
<td>RPM</td>
<td><code>xxx.rpm</code></td>
<td>√</td>
<td>已编译</td>
<td>×</td>
</tr>
<tr>
<td>SRPM</td>
<td><code>xxx.src.rpm</code></td>
<td>×</td>
<td>未编译的源码</td>
<td>√</td>
</tr>
</tbody>
</table>
<p>RPM 建包的原理并不复杂，可以理解为按照标准的格式整理一些信息，包括：软件基础信息，以及安装、卸载前后执行的<a href="http://hlee.iteye.com/blog/343499" target="_blank" rel="external">脚本</a>，对源码包解压、打补丁、编译，安装路径和文件等。我们可以基于标准规范，来<a href="http://hlee.iteye.com/blog/343499" target="_blank" rel="external">使用 rpmbuild 制作自己的 RPM 包</a>。</p>
<h2 id="Mac_软件包管理工具"><a href="https://github.com/pubyun/macdev/blob/master/basic.md" target="_blank" rel="external">Mac 软件包管理工具</a></h2><p>linux 平台下的 apt-get 和 yum 命令行工具分别适用于 deb、rpm 包管理方式的发行版本，主要用于自动从互联网的软件仓库中搜索、安装、升级和卸载软件。在 Mac OS X 平台下，除了直接从 AppleStore 下载认证上架的软件进行安装外，还可以在系统偏好设置的【安全性与隐私】中允许从<strong>任何来源</strong>下载的应用。  </p>
<h3 id="dmg_&amp;_pkg">dmg &amp; pkg</h3><p>一些应用会提供 <a href="http://www.xitongzhijia.net/xtjc/20150303/39862.html" target="_blank" rel="external">dmg、pkg</a> 安装包，例如 <code>git-2.5.3-intel-universal-mavericks.dmg</code>、<code>Subversion-1.9.2_10.10.x.pkg</code>。</p>
<ol>
<li><strong>dmg</strong> 是苹果的压缩镜像文件（类似 Windows 下的 iso ），它是 Mac 应用软件通用的打包格式（相当于 ipa），里面一般包含 <code>应用程序.app</code> 的图标和一个应用程序文件夹（<code>/Applications</code>）快捷方式，直接将 <code>应用程序.app</code> 拖曳至应用程序文件夹即可完成安装。卸载也同样绿色，直接在 <code>Launchpad</code> 中或 cd 到  <code>/Applications</code> 目录下删除应用（文件夹）即可。</li>
<li><strong><a href="https://en.wikipedia.org/wiki/.pkg" target="_blank" rel="external">pkg</a></strong> 属于系统级软件的安装程序，相当于 iOS 越狱后装的 deb，一般会修改系统配置，权限较高。pkg 安装一般要求 sudo 授权，<a href="http://blog.csdn.net/play_fun_tech/article/details/27964861" target="_blank" rel="external">卸载 pkg 安装的应用</a> 也比较麻烦。pkg 类似 Windows 下的安装程序 Setup.exe 和 *.<a href="https://msdn.microsoft.com/en-us/library/cc185688" target="_blank" rel="external">msi</a>。<br> Windows 下可以使用 <a href="http://www.flexerasoftware.com/producer/products/software-installation/installshield-software-installer/" target="_blank" rel="external">Install Shield</a> 来 <a href="http://www.yesky.com/460/1843460.shtml" target="_blank" rel="external">制作安装程序</a>，可使用 Xcode 自带的 <a href="http://www.identityfinder.com/kb/Enterprise-Documentation/046141" target="_blank" rel="external">PackageMaker</a> 或打包命令行工具 <a href="http://developer.apple.com/library/mac/documentation/Darwin/Reference/Manpages/man1/pkgbuild.1.html" target="_blank" rel="external">pkgbuild</a>+<a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/productbuild.1.html" target="_blank" rel="external">productbuild</a>+<a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/pkgutil.1.html" target="_blank" rel="external">pkgutil</a> 或 <a href="http://s.sudre.free.fr/Software/Iceberg.html" target="_blank" rel="external">Iceberg</a>（an Integrated Packaging Environment (IPE) ）来<a href="http://blog.csdn.net/handsomerocco/article/details/7761212" target="_blank" rel="external">制作安装包</a>。</li>
<li><p><strong>mpkg</strong>：pkg 是单个<a href="http://blog.csdn.net/dongdongdongjl/article/details/7896771" target="_blank" rel="external">应用程序的安装包</a>，而 mpkg（multi pkg）是多个 pkg 。我们来看一下从 AppleStore 下载的 OS X EI Capitan 安装器文件——<code>安装 OS X EI Capitan.app</code> 的 <code>/Contents/SharedSupport</code> 目录：</p>
 <figure class="highlight"><table><tr><td class="code"><pre><span class="line">faner@MBP-FAN:/Applications/Install OS X El Capitan.app/Contents/SharedSupport|&#10;&#8658;  tree &#10;.&#10;&#9500;&#9472;&#9472; InstallESD.dmg&#10;&#9492;&#9472;&#9472; OSInstall.mpkg&#10;&#10;0 directories, 2 files</span><br></pre></td></tr></table></figure>
<blockquote>
<p>下载完 <code>安装 OS X EI Capitan.app</code> 之后，可以使用 <strong><code>createinstallmedia</code></strong> 命令<a href="http://bbs.feng.com/read-htm-tid-9930245.html" target="_blank" rel="external">制作 U 盘安装盘</a>，或<a href="http://bbs.feng.com/read-htm-tid-5045869.html" target="_blank" rel="external">恢复到 U 盘制作启动盘</a>。</p>
</blockquote>
</li>
<li><p><strong>dmg with pkg</strong>：像 <code>git-2.5.3-intel-universal-mavericks.dmg</code> 这种 dmg 打包的是 git command CLI 的安装 pkg，需要使用 DiskImageMounter 挂载 dmg，然后打开 pkg（使用 Installer），按照引导一步步 next 即可安装完成。当然也可使用 <a href="http://www.it165.net/os/html/201207/2764.html" target="_blank" rel="external">命令行</a> 完成挂载安装操作。</p>
</li>
</ol>
<p>除了使用 dmg、pkg 来安装软件外，Mac 下同样有优秀的软件包管理工具，可以下载、安装和管理大量 AppleStore 没有提供、而又经常会用到的开源软件。我们有两种选择 —— MacPorts 和 Homebrew。</p>
<h3 id="MacPorts"><a href="http://www.macports.org/" target="_blank" rel="external">MacPorts</a></h3><p><a href="http://chenpeng.info/html/1753" target="_blank" rel="external">MacPorts</a> (DarwinPorts) 是由 <a href="http://www.freebsd.org/" target="_blank" rel="external">FreeBSD</a> 的 port 移植而来的软件包管理系统，，用来简化 Mac OS X和 Darwin 操作系统上软件的安装。在 Mac 中安装 MacPorts <a href="http://www.linuxidc.com/Linux/2012-01/52111.htm" target="_blank" rel="external">让你在Mac 的 Shell 下更加游刃有余</a>。<br><a href="http://blog.csdn.net/maojudong/article/details/7918278" target="_blank" rel="external">MacPorts</a> 有个原则，对于软件包之间的依赖，都在 MacPorts 内部（<code>/opt/local</code>）解决，无论系统本身是否包含了需要的库，都不会加以利用。这使得 MacPorts 庞大臃肿，导致系统出现大量软件包的冗余，占用不小的磁盘空间，同时稍大型一点的软件编译时间都会难以忍受。</p>
<h3 id="Homebrew"><a href="http://brew.sh/" target="_blank" rel="external">Homebrew</a></h3><p><a href="http://blog.csdn.net/delphiwcdj/article/details/19679891" target="_blank" rel="external">Homebrew</a>（简称 brew）是 Mac OS X 不可或缺的软件管理工具(The missing package manager for OS X)，<a href="http://snowolf.iteye.com/blog/774312" target="_blank" rel="external">让 Mac 拥有类似 apt-get 的功能</a>，用以简化软件的安装、升级和卸载过程。</p>
<blockquote>
<p><strong>Homebrew</strong> is the easiest and most flexible way to install the UNIX tools.</p>
</blockquote>
<p>Homebrew 是一款使用 Ruby 进行开发的托管于 <a href="https://github.com/Homebrew/homebrew" target="_blank" rel="external">GitHub</a> 上的自由及开放源代码的软件包管理系统，通过用户的贡献扩大对软件包的支持。</p>
<h3 id="MacPorts_vs_Homebrew">MacPorts vs Homebrew</h3><p>MacPorts 和 Homebrew 这两种包管理系统的工作方式都是下载源代码，然后在本地编译。但是这两种包管理系统还是存在很大差异的，主要差异有以下三点：</p>
<ul>
<li>MacPorts 的理念是尽量减少对系统现有库的依赖，编译时间较长；而 Homebrew 则是尽量依赖系统现有库，编译时间会显著减少。</li>
<li>MacPorts 的 Package 是安装到 <code>/opt/local</code> ，不会与系统现有的软件发生冲突；而 Homebrew 的 Package 是安装到 <code>/usr/local</code>，可能与系统自带的软件发生冲突。</li>
<li>Macports 使用 rsync 进行同步（<a href="https://trac.macports.org/wiki/howto/SyncingWithSVN" target="_blank" rel="external">也可以使用svn</a>），而 Homebrew 使用 git 进行同步。</li>
</ul>
<p>总体来说，Homebrew 使用简单，编译时间短，比较适合新手使用。MacPorts 编译时间长，命令还要带上 sudo，易用性上没有 Homebrew 好，但是比较干净，适合有洁癖的人使用。</p>
<p>以上梳理了 Linux 和 Mac 下的包管理机制，下面重点介绍 Mac OS X 上的包管理 CLI 命令行工具 brew 及其增强工具 brew-cask。</p>
<h2 id="brew_(homebrew)">brew (homebrew)</h2><p><strong>brew</strong> 是从软件包仓库下载源代码码到本地进行解压，进而执行 <code>./configure</code> &amp;&amp; <code>make install</code> ，将软件编译安装到单独的目录（<code>/usr/local/Cellar</code>）下，然后软链（symlink）到 <code>/usr/local</code> 目录下，同时会自动检测下载相关依赖库，并自动配置好各种环境变量。<br>这个对程序员来说简直是福音，使用简单的指令就能快速安装、升级和卸载本地的各种开发环境。</p>
<h3 id="安装_brew">安装 brew</h3><p>brew 的安装很简单，使用一条 ruby 命令调用 curl 下载安装即可。</p>
<p><strong>1.Mac OS X 上默认已安装 <a href="https://www.ruby-lang.org/" target="_blank" rel="external">ruby</a>：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">faner@MBP-FAN:~|⇒  ruby -v</span><br><span class="line">ruby <span class="number">2.0</span><span class="number">.0</span>p645 (<span class="number">2015</span>-<span class="number">04</span>-<span class="number">13</span> revision <span class="number">50299</span>) [universal.x86_64-darwin15]</span><br></pre></td></tr></table></figure>
<p><strong>2.Mac OS X 上默认已内置了 <a href="http://curl.haxx.se/" target="_blank" rel="external">curl</a>（Command Line URL Viewer）：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">faner@MBP-FAN:~|⇒  curl --version</span><br><span class="line">curl <span class="number">7.43</span><span class="number">.0</span> (x86_64-apple-darwin15<span class="number">.0</span>) libcurl/<span class="number">7.43</span><span class="number">.0</span> SecureTransport zlib/<span class="number">1.2</span><span class="number">.5</span></span><br><span class="line">Protocols: dict file ftp ftps gopher http https imap imaps ldap ldaps pop3 pop3s rtsp smb smbs smtp smtps telnet tftp </span><br><span class="line">Features: AsynchDNS IPv6 Largefile GSS-API Kerberos SPNEGO NTLM NTLM_WB SSL libz UnixSockets</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<blockquote>
<p><strong>curl</strong> 是基于跨平台网络协议库 <a href="http://blog.csdn.net/mac_cm/article/details/6670154" target="_blank" rel="external">libcurl</a> 的利用 URL 语法在命令行方式下工作的开源文件传输工具。<br><a href="http://www.cnblogs.com/gbyukg/p/3326825.html" target="_blank" rel="external">curl常用命令</a> 可参考  <a href="http://blog.csdn.net/fudesign2008/article/details/7608619" target="_blank" rel="external">curl 详解</a>、<a href="http://www.ruanyifeng.com/blog/2011/09/curl.html" target="_blank" rel="external">curl网站开发指南</a>。</p>
</blockquote>
<h4 id="旧的安装"><a href="http://blog.csdn.net/jiajiayouba/article/details/44261011" target="_blank" rel="external">旧的安装</a></h4><p>很早之前，homebrew 的安装 url 是 <code>https://raw.github.com/Homebrew/homebrew/go/install</code>：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">ruby -e &#34;$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)&#34;</span><br></pre></td></tr></table></figure>
<p>首次执行 <code>brew install</code> 安装软件时，将提示不能创建 <code>/usr/local/Cellar</code> 目录，原因是没有 <code>/usr/local</code> 的写权限。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  ~  brew install node&#10;Error: Could not create /usr/local/Cellar&#10;Check you have permission to write to /usr/local</span><br></pre></td></tr></table></figure>
<p><strong><a href="http://segmentfault.com/q/1010000000505091" target="_blank" rel="external">解决方法</a>：</strong></p>
<blockquote>
<p>执行 <code>chown</code> 命令改变 <code>/usr/local</code> 的所有者为 <code>whoami</code> ，<code>-R</code> 表示递归（Recursive）。</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  ~  whoami&#10;faner&#10;&#10;&#10140;  ~  sudo chown -R faner /usr/local</span><br></pre></td></tr></table></figure>
<h4 id="新的安装">新的安装</h4><p>可以在 <a href="http://brew.sh/index.html" target="_blank" rel="external">brew 的官网首页</a>的末尾看到最新的安装代码：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">ruby -e &#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&#34;</span><br></pre></td></tr></table></figure>
<p>最新的安装过程中将会要求输入密码授权 <code>sudo chown ${whoami} /usr/local/*</code> ：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">~ $ brew&#10;-bash: brew: command not found&#10;~ $ ruby -e &#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&#34;&#10;==&#62; This script will install:&#10;/usr/local/bin/brew&#10;/usr/local/Library/...&#10;/usr/local/share/man/man1/brew.1&#10;==&#62; The following directories will be made group writable:&#10;/usr/local/.&#10;/usr/local/bin&#10;/usr/local/include&#10;/usr/local/lib&#10;/usr/local/lib/pkgconfig&#10;==&#62; The following directories will have their owner set to thomasfan:&#10;/usr/local/.&#10;/usr/local/bin&#10;/usr/local/include&#10;/usr/local/lib&#10;/usr/local/lib/pkgconfig&#10;==&#62; The following directories will have their group set to admin:&#10;/usr/local/.&#10;/usr/local/bin&#10;/usr/local/include&#10;/usr/local/lib&#10;/usr/local/lib/pkgconfig&#10;&#10;Press RETURN to continue or any other key to abort&#10;==&#62; /usr/bin/sudo /bin/chmod g+rwx /usr/local/. /usr/local/bin /usr/local/include /usr/local/lib /usr/local/lib/pkgconfig&#10;Password:&#10;==&#62; /usr/bin/sudo /usr/sbin/chown thomasfan /usr/local/. /usr/local/bin /usr/local/include /usr/local/lib /usr/local/lib/pkgconfig&#10;==&#62; /usr/bin/sudo /usr/bin/chgrp admin /usr/local/. /usr/local/bin /usr/local/include /usr/local/lib /usr/local/lib/pkgconfig&#10;==&#62; /usr/bin/sudo /bin/mkdir /Library/Caches/Homebrew&#10;==&#62; /usr/bin/sudo /bin/chmod g+rwx /Library/Caches/Homebrew&#10;==&#62; /usr/bin/sudo /usr/sbin/chown thomasfan /Library/Caches/Homebrew&#10;==&#62; Downloading and installing Homebrew...&#10;remote: Counting objects: 3847, done.&#10;remote: Compressing objects: 100% (3691/3691), done.&#10;remote: Total 3847 (delta 40), reused 520 (delta 21), pack-reused 0&#10;Receiving objects: 100% (3847/3847), 3.31 MiB | 105.00 KiB/s, done.&#10;Resolving deltas: 100% (40/40), done.&#10;From https://github.com/Homebrew/homebrew&#10; * [new branch]      master     -&#62; origin/master&#10;HEAD is now at e191c00 jsonnet: update 0.8.5 bottle.&#10;==&#62; Installation successful!&#10;==&#62; Next steps&#10;Run `brew help` to get started&#10;~ $</span><br></pre></td></tr></table></figure>
<h3 id="brew_help">brew help</h3><h4 id="brew_-v_/_–version">brew -v / –version</h4><p>安装完 brew，执行 <code>brew -v</code> 命令可以查看安装的 brew 版本信息：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">faner@MBP-FAN:~|&#8658;  brew -v&#10;Homebrew 0.9.5 (git revision 1eec1; last commit 2015-11-21)&#10;faner@MBP-FAN:~|&#8658;  brew --version&#10;0.9.5 (git revision 1eec1; last commit 2015-11-21)</span><br></pre></td></tr></table></figure>
<h4 id="brew_常用命令">brew 常用命令</h4><p>执行 <code>brew</code> 查看帮助概要（Example usage、Troubleshooting、Brewing）：</p>
<blockquote>
<p>-h / –h / –help / help</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">faner@MBP-FAN:~|&#8658;  brew&#10;Example usage:&#10;  brew [info | home | options ] [FORMULA...]&#10;  brew install FORMULA...&#10;  brew uninstall FORMULA...&#10;  brew search [foo]&#10;  brew list [FORMULA...]&#10;  brew update&#10;  brew upgrade [FORMULA...]&#10;  brew pin/unpin [FORMULA...]&#10;&#10;Troubleshooting:&#10;  brew doctor&#10;  brew install -vd FORMULA&#10;  brew [--env | config]&#10;&#10;Brewing:&#10;  brew create [URL [--no-fetch]]&#10;  brew edit [FORMULA...]&#10;  https://github.com/Homebrew/homebrew/blob/master/share/doc/homebrew/Formula-Cookbook.md&#10;&#10;Further help:&#10;  man brew&#10;  brew home</span><br></pre></td></tr></table></figure>
<ol>
<li>执行 <code>man brew</code> 可查看详细的 brew 帮助文档。</li>
<li>执行 <code>man home</code> 可调用浏览器打开 brew 官方网站。</li>
</ol>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>brew update</td>
<td>更新 brew</td>
</tr>
<tr>
<td>brew search FORMULA</td>
<td>查找软件包，可使用正则表达式</td>
</tr>
<tr>
<td>brew info FORMULA</td>
<td>显示软件的信息</td>
</tr>
<tr>
<td>brew deps FORMULA</td>
<td>显示包依赖</td>
</tr>
<tr>
<td>brew install FORMULA</td>
<td><a href="http://www.cnblogs.com/TankXiao/p/3247113.html" target="_blank" rel="external">安装软件包</a></td>
</tr>
<tr>
<td>brew uninstall FORMULA</td>
<td>卸载软件包</td>
</tr>
<tr>
<td>brew list</td>
<td>列出已安装的软件包，可指定 FORMULA</td>
</tr>
<tr>
<td>brew outdated</td>
<td>列出可升级的软件包</td>
</tr>
<tr>
<td>brew upgrade</td>
<td>更新已安装的软件包，可指定 FORMULA</td>
</tr>
<tr>
<td>brew doctor</td>
<td>诊断 homebrew 环境</td>
</tr>
<tr>
<td>brew prune</td>
<td>删除 /usr/local 下的无效链接(remove broken symlinks)</td>
</tr>
</tbody>
</table>
<h4 id="brew_info">brew info</h4><p><strong><code>brew info</code></strong> 显示软件包信息，一般包括：</p>
<ul>
<li>软件概要信息</li>
<li>本地是否已安装：Not installed / Poured from bottle</li>
<li>依赖包：==&gt; Dependencies，Build、Required、Recommended、Optional</li>
<li>编译、安装选项： ==&gt; Options</li>
<li>预警信息：==&gt; Caveats</li>
</ul>
<p><a href="https://ruby-china.org/topics/21050" target="_blank" rel="external">brew info 查看 plist 文件</a></p>
<h3 id="brew_install_示例">brew install 示例</h3><h4 id="tree">tree</h4><p>linux 下的 <strong><a href="http://mama.indstate.edu/users/ice/tree/" target="_blank" rel="external">tree</a></strong> 命令以树形结构显示文件目录结构，Mac 下默认并没有该命令，只有普通的 <strong><code>ls</code></strong> 命令。可以利用 brew 查找并安装 tree 命令行工具：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">faner@MBP-FAN:~|&#8658;  brew search tree&#10;git-stree       mvptree         pstree          tree            treecc          treeline      &#10;homebrew/emacs/dict-tree        homebrew/science/quicktree      Caskroom/cask/treemaker       &#10;homebrew/emacs/undo-tree        homebrew/x11/prooftree          Caskroom/cask/treesheets      &#10;homebrew/emacs/ztree-emacs      Caskroom/cask/figtree         &#10;homebrew/science/fasttree       Caskroom/cask/sourcetree      &#10;faner@MBP-FAN:~|&#8658;  brew info tree&#10;tree: stable 1.7.0 (bottled)&#10;Display directories as trees (with optional color/HTML output)&#10;http://mama.indstate.edu/users/ice/tree/&#10;Not installed&#10;From: https://github.com/Homebrew/homebrew/blob/master/Library/Formula/tree.rb&#10;faner@MBP-FAN:~|&#8658;  brew deps tree&#10;faner@MBP-FAN:~|&#8658;  brew install tree&#10;==&#62; Downloading https://homebrew.bintray.com/bottles/tree-1.7.0.el_capitan.bottle.1.tar.gz&#10;######################################################################## 100.0%&#10;==&#62; Pouring tree-1.7.0.el_capitan.bottle.1.tar.gz&#10;&#127866;  /usr/local/Cellar/tree/1.7.0: 7 files, 128K&#10;faner@MBP-FAN:~|&#8658;  tree --version&#10;tree v1.7.0 (c) 1996 - 2014 by Steve Baker, Thomas Moore, Francesc Rocher, Florian Sesser, Kyosuke Tokoro</span><br></pre></td></tr></table></figure>
<ol>
<li>homebrew 下载已经编译好的二进制包 tree 到缓存目录 <code>/Library/Caches/Homebrew/tree-1.7.0.el_capitan.bottle.1.tar.gz</code></li>
<li>解压 <code>tree-1.7.0.el_capitan.bottle.1.tar.gz</code> 到 <code>/usr/local/Cellar/tree/</code> 目录，根据版本存放到文件夹 <code>1.7.0</code> 下。</li>
<li>将 <code>/usr/local/Cellar/tree/1.7.0/bin/tree</code> 软链到 <code>/usr/local/bin/tree</code>，后者是前者的替身，执行 tree 命令时，真正调用的是其在 Cellar 中的真身。</li>
</ol>
<h4 id="axel">axel</h4><p>以下示例查找比 wget 下载速度高几倍的支持<a href="http://www.pooy.net/axel-download-helper.html" target="_blank" rel="external">断点续传</a>的<a href="http://www.cnblogs.com/SunWentao/archive/2008/07/10/1239924.html" target="_blank" rel="external">多线程</a>下载 CLI 命令行工具 <strong><a href="http://wilmer.gaast.net/main.php/axel.html" target="_blank" rel="external">axel</a></strong>，并显示软件包信息和依赖关系，然后安装该工具：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">faner@MBP-FAN:~|&#8658;  brew search axel&#10;axel&#10;faner@MBP-FAN:~|&#8658;  brew info axel&#10;axel: stable 2.4 (bottled)&#10;Light UNIX download accelerator&#10;https://packages.debian.org/sid/axel&#10;Not installed&#10;From: https://github.com/Homebrew/homebrew/blob/master/Library/Formula/axel.rb&#10;faner@MBP-FAN:~|&#8658;  brew deps axel&#10;faner@MBP-FAN:~|&#8658;  &#10;faner@MBP-FAN:~|&#8658;  brew install axel&#10;==&#62; Downloading https://homebrew.bintray.com/bottles/axel-2.4.el_capitan.bottle.1.tar.gz&#10;###############################################                           66.5%&#10;curl: (56) SSLRead() return error -9806&#10;Error: Failed to download resource &#34;axel&#34;&#10;Download failed: https://homebrew.bintray.com/bottles/axel-2.4.el_capitan.bottle.1.tar.gz&#10;Warning: Bottle installation failed: building from source.&#10;==&#62; Downloading https://mirrors.ocf.berkeley.edu/debian/pool/main/a/axel/axel_2.4.orig.tar.gz&#10;######################################################################## 100.0%&#10;==&#62; ./configure --prefix=/usr/local/Cellar/axel/2.4 --debug=0 --i18n=0&#10;==&#62; make&#10;==&#62; make install&#10;&#127866;  /usr/local/Cellar/axel/2.4: 8 files, 104K, built in 13 seconds&#10;faner@MBP-FAN:~|&#8658;  axel -V&#10;Axel version 2.4 (Darwin)&#10;&#10;Copyright 2001-2002 Wilmer van der Gaast.</span><br></pre></td></tr></table></figure>
<ol>
<li>从 homebrew 官方仓库 <code>homebrew.bintray.com</code> 下载 axel 失败后，自动从镜像源 <code>mirrors.ocf.berkeley.edu</code> 重新下载。下载的源码缓存到目录 <code>/Library/Caches/Homebrew/axel-2.4.tar.gz</code>。</li>
<li>下载完成后，依次执行 <code>./configure</code>、<code>make</code> 和 <code>make install</code> 将软件编译安装到 <code>/usr/local/Cellar/axel/</code> 目录下，根据版本存放到文件夹 <code>2.4</code> 下。</li>
<li>将 <code>usr/local/Cellar/axel/2.4/bin/axel</code> 软链到 <code>/usr/local/bin/axel</code>，后者是前者的替身，执行 axel 命令时，真正调用的是其在 Cellar 中的真身。</li>
</ol>
<h4 id="subversion"><a href="https://subversion.apache.org/packages.html#osx" target="_blank" rel="external">subversion</a></h4><p><code>search-info-deps-install</code> 过程日志参考 <a href="http://pan.baidu.com/s/1genD2JT" target="_blank" rel="external">brew install subversion.log</a>。</p>
<h2 id="brew_cask"><a href="http://www.zhihu.com/question/22624898" target="_blank" rel="external">brew cask</a></h2><p>Homebrew 作为 Ruby 社区极富想象力的作品，使得 Mac 下安装 Mysql 等常用包不再困难。那么，是否也可以通过 <code>brew install mysql</code> 这样简单的方式来安装 Google Chrome 浏览器呢？为解决这一问题，phinze 的作品 <a href="https://github.com/phinze/homebrew-cask" target="_blank" rel="external">homebrew-cask</a> 应运而生。</p>
<h3 id="about">about</h3><p>Homebrew 可以管理 Mac 下的命令行工具（wget、node），<strong>brew cask</strong> 则是一套建立在 brew 上的<strong>增强</strong>命令行工具，支持管理 Mac 下的 GUI 程序，例如 qq、 google-chrome、evernote 等。<br>cask 从镜像源下载已经编译好了的<a href="https://github.com/phinze/homebrew-cask/tree/master/Casks" target="_blank" rel="external">应用软件二进制包</a>（.dmg/.pkg）到本地解压到单独的目录（<code>/opt/homebrew-cask/Caskroom</code>）下，然后软链（symlink）到 <code>/Applications</code> 目录下。<br>cask 包含了很多在 AppStore 里没有的常用软件，省掉了手动下载、解压、拖拽（安装）等步骤，且卸载也相当容易与干净，使用起来非常方便。</p>
<p>假设你已安装好了 Homebrew，执行以下命令查找 <code>cask</code> 包并显示软件包信息和依赖关系：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">faner@MBP-FAN:~|&#8658;  brew search cask&#10;cask&#10;homebrew/completions/brew-cask-completion&#10;&#10;faner@MBP-FAN:~|&#8658;  brew info cask&#10;cask: stable 0.7.3, HEAD&#10;Emacs dependency management&#10;https://cask.readthedocs.org/&#10;Not installed&#10;From: https://github.com/Homebrew/homebrew/blob/master/Library/Formula/cask.rb&#10;&#10;faner@MBP-FAN:~|&#8658;  brew deps cask&#10;emacs</span><br></pre></td></tr></table></figure>
<h3 id="install">install</h3><p>安装 cask 极其简单，打开终端输入：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">brew tap phinze/homebrew-cask&#10;brew install brew-cask</span><br></pre></td></tr></table></figure>
<h4 id="brew_tap_phinze/homebrew-cask">brew tap phinze/homebrew-cask</h4><p>由于 brew 和包含的包源都是通过 github 来管理，人为的维护管理。除了默认的仓库，还允许别人的源添加进来。通过 <a href="http://icyleaf.com/2014/01/homebrew-hidden-commands/" target="_blank" rel="external"><code>brew tap</code></a> 指定第三方包源：</p>
<blockquote>
<p>$ brew tap <gihhub_user repo=""></gihhub_user></p>
</blockquote>
<p>默认的源是 <code>caskroom/cask</code>，以下显式 tap 原作者的源（<code>phinze/homebrew-cask</code>）：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">faner<span class="annotation">@MBP</span>-<span class="string">FAN:</span>~|⇒  brew tap phinze/homebrew-cask</span><br><span class="line">==&gt; Tapping phinze/cask</span><br><span class="line">Cloning into <span class="string">'/usr/local/Library/Taps/phinze/homebrew-cask'</span>...</span><br><span class="line"><span class="string">remote:</span> Counting <span class="string">objects:</span> <span class="number">3278</span>, done.</span><br><span class="line"><span class="string">remote:</span> Compressing <span class="string">objects:</span> <span class="number">100</span>% (<span class="number">3202</span>/<span class="number">3202</span>), done.</span><br><span class="line"><span class="string">remote:</span> Total <span class="number">3278</span> (delta <span class="number">83</span>), reused <span class="number">731</span> (delta <span class="number">59</span>), pack-reused <span class="number">0</span></span><br><span class="line">Receiving <span class="string">objects:</span> <span class="number">100</span>% (<span class="number">3278</span><span class="regexp">/3278), 5.82 MiB | 428.00 KiB/</span>s, done.</span><br><span class="line">Resolving <span class="string">deltas:</span> <span class="number">100</span>% (<span class="number">83</span>/<span class="number">83</span>), done.</span><br><span class="line">Checking connectivity... done.</span><br><span class="line">Tapped <span class="number">1</span> formula (<span class="number">3257</span> files, <span class="number">24</span>M)</span><br></pre></td></tr></table></figure>
<h4 id="brew_install_brew-cask">brew install brew-cask</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">faner@MBP-FAN:~|&#8658;  brew install brew-cask&#10;==&#62; Installing brew-cask from phinze/homebrew-cask&#10;==&#62; Cloning https://github.com/caskroom/homebrew-cask.git&#10;Cloning into &#39;/Library/Caches/Homebrew/brew-cask--git&#39;...&#10;remote: Counting objects: 3248, done.&#10;remote: Compressing objects: 100% (3172/3172), done.&#10;remote: Total 3248 (delta 82), reused 771 (delta 59), pack-reused 0&#10;Receiving objects: 100% (3248/3248), 5.82 MiB | 467.00 KiB/s, done.&#10;Resolving deltas: 100% (82/82), done.&#10;Checking connectivity... done.&#10;Note: checking out &#39;d39c95942f4226fb6c0e1a56c11008695ddeeade&#39;.&#10;&#10;You are in &#39;detached HEAD&#39; state. You can look around, make experimental&#10;changes and commit them, and you can discard any commits you make in this&#10;state without impacting any branches by performing another checkout.&#10;&#10;If you want to create a new branch to retain commits you create, you may&#10;do so (now or later) by using -b with the checkout command again. Example:&#10;&#10;  git checkout -b &#60;new-branch-name&#62;&#10;&#10;==&#62; Checking out tag v0.59.0&#10;&#127866;  /usr/local/Cellar/brew-cask/0.59.0: 2976 files, 12M, built in 32 seconds</span><br></pre></td></tr></table></figure>
<p>本机已经安装了 <code>brew-cask</code> 的依赖软件 <strong><code>emacs</code></strong> :</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">faner@MBP-FAN:~|&#8658;  whereis emacs&#10;/usr/bin/emacs&#10;&#10;faner@MBP-FAN:~|&#8658;  emacs --version&#10;GNU Emacs 22.1.1&#10;Copyright (C) 2007 Free Software Foundation, Inc.&#10;GNU Emacs comes with ABSOLUTELY NO WARRANTY.&#10;You may redistribute copies of Emacs&#10;under the terms of the GNU General Public License.&#10;For more information about these matters, see the file named COPYING.</span><br></pre></td></tr></table></figure>
<p>如果没有安装 <strong><code>emacs</code></strong>，则 brew 在安装 cask 之前会自动帮我们下载安装 <code>emacs</code>：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">==&#62; Installing dependencies for cask: emacs&#10;==&#62; Installing cask dependency: emacs&#10;==&#62; Downloading https://homebrew.bintray.com/bottles/emacs-24.5.yosemite.bottle.1.tar.gz&#10;######################################################################## 100.0%&#10;==&#62; Pouring emacs-24.5.yosemite.bottle.1.tar.gz&#10;==&#62; Caveats&#10;To have launchd start emacs at login:&#10;  ln -sfv /usr/local/opt/emacs/*.plist ~/Library/LaunchAgents&#10;Then to load emacs now:&#10;  launchctl load ~/Library/LaunchAgents/homebrew.mxcl.emacs.plist&#10;==&#62; Summary&#10;&#127866;  /usr/local/Cellar/emacs/24.5: 3915 files, 105M</span><br></pre></td></tr></table></figure>
<h4 id="brew_cask-1">brew cask</h4><p>执行 <code>brew cask</code> 或 <code>brew-cask</code> 可查看帮助概要（首次需输入 sudo 密码）：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">faner@MBP-FAN:~|&#8658;  brew cask&#10;==&#62; We need to make Caskroom for the first time at /opt/homebrew-cask/Caskroom&#10;==&#62; We&#39;ll set permissions properly so we won&#39;t need sudo in the future&#10;Password:&#10;brew-cask provides a friendly homebrew-style CLI workflow for the&#10;administration of Mac applications distributed as binaries.&#10;&#10;!! &#10;!! no command verb: &#10;!! &#10;&#10;Commands:&#10;&#10;    audit      verifies installability of Casks&#10;    cat        dump raw source of the given Cask to the standard output&#10;    cleanup    cleans up cached downloads and tracker symlinks&#10;    create     creates the given Cask and opens it in an editor&#10;    doctor     checks for configuration issues&#10;    edit       edits the given Cask&#10;    fetch      downloads Cask resources to local cache&#10;    home       opens the homepage of the given Cask&#10;    info       displays information about the given Cask&#10;    install    installs the given Cask&#10;    list       with no args, lists installed Casks; given installed Casks, lists staged files&#10;    search     searches all known Casks&#10;    uninstall  uninstalls the given Cask&#10;    update     a synonym for &#39;brew update&#39;&#10;    zap        zaps all files associated with the given Cask&#10;&#10;See also &#34;man brew-cask&#34;</span><br></pre></td></tr></table></figure>
<p>执行 <code>brew-cask --version</code> 命令可以查看安装的 brew-cask 版本信息：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">faner@MBP-FAN:~|&#8658;  brew-cask --version&#10;0.59.0</span><br></pre></td></tr></table></figure>
<h3 id="command_usage">command usage</h3><p><strong>brew cask 大部分命令和 brew 保持一致，新增了以下几条命令：</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>brew cask audit</td>
<td>查询指定 Cask 的可安装性</td>
</tr>
<tr>
<td>brew cask cat</td>
<td>查看指定 Cask 安装源信息</td>
</tr>
<tr>
<td>brew cask zap</td>
<td>打包指定 Cask</td>
</tr>
<tr>
<td>brew cask cleanup</td>
<td>清理缓存及软链</td>
</tr>
</tbody>
</table>
<p>安装了 cask 之后，就可以像 brew 一样来搜索安装软件，以下示例 google-chrome ：</p>
<h4 id="搜索安装包">搜索安装包</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">faner@MBP-FAN:~|&#8658;  brew-cask search google-chrome&#10;==&#62; Exact match&#10;google-chrome</span><br></pre></td></tr></table></figure>
<h4 id="查询安装性">查询安装性</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">faner@MBP-FAN:~|&#8658;  brew-cask audit google-chrome&#10;audit for google-chrome: passed</span><br></pre></td></tr></table></figure>
<h4 id="查询包信息">查询包信息</h4><p>1.执行 <code>brew-cask cat</code> 查询指定 Cask 的源信息：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">faner@MBP-FAN:~|&#8658;  brew-cask cat google-chrome&#10;cask :v1 =&#62; &#39;google-chrome&#39; do&#10;  version :latest&#10;  sha256 :no_check&#10;&#10;  url &#39;https://dl.google.com/chrome/mac/stable/GGRO/googlechrome.dmg&#39;&#10;  name &#39;Google Chrome&#39;&#10;  homepage &#39;https://www.google.com/chrome/&#39;&#10;  license :gratis&#10;  tags :vendor =&#62; &#39;Google&#39;&#10;&#10;  app &#39;Google Chrome.app&#39;&#10;&#10;  zap :delete =&#62; [&#10;                  &#39;~/Library/Application Support/Google/Chrome&#39;,&#10;                  &#39;~/Library/Caches/Google/Chrome&#39;,&#10;                  &#39;~/Library/Caches/com.google.Chrome&#39;,&#10;                  &#39;~/Library/Caches/com.google.Chrome.helper.EH&#39;,&#10;                  &#39;~/Library/Caches/com.google.Keystone.Agent&#39;,&#10;                  &#39;~/Library/Caches/com.google.SoftwareUpdate&#39;,&#10;                  &#39;~/Library/Google/GoogleSoftwareUpdate&#39;,&#10;                  &#39;~/Library/Logs/GoogleSoftwareUpdateAgent.log&#39;,&#10;                 ],&#10;      :rmdir  =&#62; [&#10;                  &#39;~/Library/Caches/Google&#39;,&#10;                  &#39;~/Library/Google&#39;,&#10;                 ]&#10;&#10;  caveats &#60;&#60;-EOS.undent&#10;    The Mac App Store version of 1Password won&#39;t work with a Homebrew-Cask-linked Google Chrome. To bypass this limitation, you need to either:&#10;&#10;      + Move Google Chrome to your /Applications directory (the app itself, not a symlink).&#10;      + Install 1Password from outside the Mac App Store (licenses should transfer automatically, but you should contact AgileBits about it).&#10;  EOS&#10;end</span><br></pre></td></tr></table></figure>
<p>2.执行 <code>brew-cask info</code> 查询指定 Cask 的包信息：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">faner@MBP-FAN:~|&#8658;  brew-cask info google-chrome&#10;google-chrome: latest&#10;Google Chrome&#10;https://www.google.com/chrome/&#10;Not installed&#10;https://github.com/phinze/homebrew-cask/blob/master/Casks/google-chrome.rb&#10;==&#62; Contents&#10;  Google Chrome.app (app)&#10;==&#62; Caveats&#10;The Mac App Store version of 1Password won&#39;t work with a Homebrew-Cask-linked Google Chrome. To bypass this limitation, you need to either:&#10;&#10;  + Move Google Chrome to your /Applications directory (the app itself, not a symlink).&#10;  + Install 1Password from outside the Mac App Store (licenses should transfer automatically, but you should contact AgileBits about it).</span><br></pre></td></tr></table></figure>
<h4 id="安装/卸载_应用">安装/卸载 应用</h4><p><code>brew-cask</code> 安装和卸载的命令同 <code>brew</code> ，都是使用 <code>install / uninstall</code> 。</p>
<p>1.执行 <code>brew cask install google-chrome</code> 命令安装 google-chrome：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">brew cask install google-chrome&#10;faner@MBP-FAN:~|&#8658;  brew cask install google-chrome   &#10;==&#62; Caveats&#10;The Mac App Store version of 1Password won&#39;t work with a Homebrew-Cask-linked Google Chrome. To bypass this limitation, you need to either:&#10;&#10;  + Move Google Chrome to your /Applications directory (the app itself, not a symlink).&#10;  + Install 1Password from outside the Mac App Store (licenses should transfer automatically, but you should contact AgileBits about it).&#10;&#10;==&#62; Downloading https://dl.google.com/chrome/mac/stable/GGRO/googlechrome.dmg&#10;######################################################################## 100.0%&#10;==&#62; Symlinking App &#39;Google Chrome.app&#39; to &#39;/Users/faner/Applications/Google Chrome.app&#39;&#10;&#127866;  google-chrome staged at &#39;/opt/homebrew-cask/Caskroom/google-chrome/latest&#39; (216 files, 183M)</span><br></pre></td></tr></table></figure>
<p>2.执行 <code>brew cask uninstall google-chrome</code> 命令卸载 google-chrome：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">faner@MBP-FAN:~|&#8658;  brew-cask uninstall google-chrome&#10;==&#62; Removing App symlink: &#39;/Users/faner/Applications/Google Chrome.app&#39;</span><br></pre></td></tr></table></figure>
<p><code>uninstall</code> 命令将删除 <code>/opt/homebrew-cask/Caskroom/google-chrome</code> 及其在 <code>~/Applications/</code> 下的软链（symlink）。<br>我们也可手动删除 homebrew 下载目录中缓存的 google-chrome 安装包  <code>/Library/Caches/Homebrew/google-chrome-latest.dmg</code> 及其软链 <code>/Library/Caches/Homebrew/Casks/google-chrome-latest.dmg</code> 。</p>
<h4 id="升级更新软件"><a href="https://github.com/phinze/homebrew-cask/issues/309" target="_blank" rel="external">升级更新软件</a></h4><p>brew-cask 并没有提供 brew 的 <code>upgrade</code> 命令，升级更新软件只能通过 DIY：</p>
<ol>
<li>进入应用软件的【关于】，手动检查是否可更新升级，使用软件自己的更新流程。</li>
<li>卸载重装 (<code>brew cask uninstall</code> &amp;&amp; <code>brew cask install</code>) ，实现间接升级。</li>
</ol>
<h3 id="brew-cask_install_示例">brew-cask install 示例</h3><h4 id="文件预览插件"><a href="http://www.cocoachina.com/mac/20141112/10198.html" target="_blank" rel="external">文件预览插件</a></h4><p>有些插件可以让 Mac 上的文件预览更有效，比如语法高亮、markdown 渲染、json 预览等等。通过 <code>brew cask install</code> 命令可以安装这些插件：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">$ brew cask install qlcolorcode&#10;$ brew cask install qlstephen&#10;$ brew cask install qlmarkdown&#10;$ brew cask install quicklook-json&#10;$ brew cask install qlprettypatch&#10;$ brew cask install quicklook-csv&#10;$ brew cask install betterzipql&#10;$ brew cask install webp-quicklook&#10;$ brew cask install suspicious-package</span><br></pre></td></tr></table></figure>
<h4 id="Visual_Studio_Code"><a href="https://code.visualstudio.com/" target="_blank" rel="external">Visual Studio Code</a></h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">~ $ brew cask search visual-studio-code&#10;==&#62; Exact match&#10;visual-studio-code&#10;~ $ brew-cask cat visual-studio-code&#10;cask :v1 =&#62; &#39;visual-studio-code&#39; do&#10;  version &#39;0.10.1&#39;&#10;  sha256 &#39;b71089670b3c2a259bf26ad6a6ad7b0abc9bb805353e8087f5c86361a5f8defc&#39;&#10;&#10;  # vo.msecnd.net is the official download host per the vendor homepage&#10;  url &#34;https://az764295.vo.msecnd.net/public/#&#123;version&#125;-release/VSCode-darwin.zip&#34;&#10;  name &#39;Visual Studio Code&#39;&#10;  homepage &#39;https://code.visualstudio.com/&#39;&#10;  license :mit&#10;  tags :vendor =&#62; &#39;Microsoft&#39;&#10;&#10;  app &#39;Visual Studio Code.app&#39;&#10;&#10;  zap :delete =&#62; [&#10;                  &#39;~/Library/Application Support/Code&#39;,&#10;                  &#39;~/Library/Caches/Code&#39;,&#10;                 ]&#10;end&#10;~ $ brew-cask info visual-studio-code&#10;visual-studio-code: 0.10.1&#10;Visual Studio Code&#10;https://code.visualstudio.com/&#10;Not installed&#10;https://github.com/caskroom/homebrew-cask/blob/master/Casks/visual-studio-code.rb&#10;==&#62; Contents&#10;  Visual Studio Code.app (app)&#10;~ $ brew-cask audit visual-studio-code&#10;audit for visual-studio-code: passed&#10;~ $ brew cask install visual-studio-code&#10;==&#62; Downloading https://az764295.vo.msecnd.net/public/0.10.1-release/VSCode-darwin.zip&#10;######################################################################## 100.0%&#10;==&#62; Symlinking App &#39;Visual Studio Code.app&#39; to &#39;/Users/thomasfan/Applications/Visual Studio Code.app&#39;&#10;&#127866;  visual-studio-code staged at &#39;/opt/homebrew-cask/Caskroom/visual-studio-code/0.10.1&#39; (1675 files, 177M)</span><br></pre></td></tr></table></figure>
<h4 id="Wireshark"><a href="https://www.wireshark.org/" target="_blank" rel="external">Wireshark</a></h4><p><code>search-info-cat-audit-install</code> 过程日志参考 <a href="http://pan.baidu.com/s/1bnKFxkr" target="_blank" rel="external">brew-cask install wireshark.log</a>。</p>
<h2 id="参考">参考</h2><p><a href="http://my.oschina.net/evilgod528/blog/306548" target="_blank" rel="external">Mac 利器：brew、brew cask、zsh</a><br><a href="http://www.yangzhiping.com/tech/homebrew-cask.html" target="_blank" rel="external">Mac安装软件新方法：Homebrew-cask</a><br><a href="http://ksmx.me/homebrew-cask-cli-workflow-to-install-mac-applications/" target="_blank" rel="external">简洁优雅的Mac OS X软件安装体验 - homebrew-cask</a><br><a href="http://blog.devtang.com/blog/2014/02/26/the-introduction-of-homebrew-and-brewcask/" target="_blank" rel="external">使用brew cask来安装Mac应用</a><br><a href="http://blog.csdn.net/flymorn/article/details/43112813" target="_blank" rel="external">Mac下通过 brew 安装不同版本的 PHP</a>  </p>
<p><a href="http://www.osxtoy.com/?p=2431" target="_blank" rel="external">Launchrocket 帮助管理 Homebrew 安装的服务</a><br><a href="http://my.oschina.net/gujianhan/blog/204122" target="_blank" rel="external">homebrew cask 安装 launchrocket</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文前驱铺垫梳理了从 linux 源码安装软件到 DPKG/RPM 软件包管理机制，阐述了 *UNX 平台的软件安装包管理机制的演变和现代化。<br>后半部分介绍了 Mac 下的软件安装包格式 —— pkg &amp; dmg，以及软件包管理工具 —— brew 及 brew-cask，并梳理日常 Command Usage。</p>]]>
    
    </summary>
    
      <category term="APT" scheme="http://col.dog/tags/APT/"/>
    
      <category term="DPKG" scheme="http://col.dog/tags/DPKG/"/>
    
      <category term="Homebrew" scheme="http://col.dog/tags/Homebrew/"/>
    
      <category term="MacPorts" scheme="http://col.dog/tags/MacPorts/"/>
    
      <category term="RPM" scheme="http://col.dog/tags/RPM/"/>
    
      <category term="SRPM" scheme="http://col.dog/tags/SRPM/"/>
    
      <category term="YUM" scheme="http://col.dog/tags/YUM/"/>
    
      <category term="brew" scheme="http://col.dog/tags/brew/"/>
    
      <category term="brew-cask" scheme="http://col.dog/tags/brew-cask/"/>
    
      <category term="dmg" scheme="http://col.dog/tags/dmg/"/>
    
      <category term="pkg" scheme="http://col.dog/tags/pkg/"/>
    
      <category term="Mac" scheme="http://col.dog/categories/Mac/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Markdown 语法基础及使用教程]]></title>
    <link href="http://col.dog/2015/11/22/Markdown-Syntax/"/>
    <id>http://col.dog/2015/11/22/Markdown-Syntax/</id>
    <published>2015-11-22T06:36:00.000Z</published>
    <updated>2015-11-22T06:57:35.000Z</updated>
    <content type="html"><![CDATA[<p>Markdown 的目标是实现「易读易写」（easy-to-read and easy-to-write ）。<br>本文结合示例实践，系统梳理总结了 Markdown 纯文本写作标记语言的语法基础和使用过程中的诸多规范细节。<br>本文最早发表于本人 CSDN 博客 —— <a href="http://blog.csdn.net/phunxm?viewmode=list" target="_blank" rel="external">Markdown 基础教程</a>。</p>
<a id="more"></a>
<h2 id="注释（Comment）">注释（Comment）</h2><p>注释是写作者自己的标注记录，不被浏览器解析渲染。<br>HTML 以 <code>&lt;!--</code> 开头，以 <code>--&gt;</code> 结尾的闭包定义注释（支持跨行），不在正文中显示。<br>Markdown 沿用 <a href="http://home.wangjianshuo.com/cn/20070526_aeaeaehtmleccommentie.htm" target="_blank" rel="external">HTML Comment</a> 注释格式：<br><code>&lt;!-- This text will not appear in the browser window. --&gt;</code><br><!-- This text will not appear in the browser window. --></p>
<p><strong>注释适用场景示例：</strong></p>
<ol>
<li><p>CSDN 博客默认会在网页生成TOC，而 GitHub 仍不支持<code>[TOC]</code>，因此在发布 Markdown 博客时可注释掉开头的 [TOC] 标签，在需要查看 OUTLINE 时再打开。<br><code>&lt;!--[TOC]--&gt;</code></p>
</li>
<li><p>在博客 Markdown 源码开头，我通常使用注释来备注 git commit-hash-id 和 commit-date 信息（git log -p ），以便修订变更时回溯。<br><code>&lt;!--commit 5326f29752b7ee3472aa00b40574bd585e3ef25b--&gt;</code><br><code>&lt;!--Mon Nov 2 00:36:40 2015 +0800--&gt;</code></p>
</li>
<li><p>在使用 Markdown 写作博客时，我喜欢采用参考式链接，然后在文末专门开辟一节用于定义文中用到的所有脚注和参考链接。借助 Haroopad/FoldingText/Marked2 的折叠特性，我习惯在末尾添加一行 Comment Heading，用于在阅读 Markdown 源码时折叠隐藏文末的参考区。<br><code>##&lt;!--以下是本文的脚注和超链接--&gt;</code></p>
</li>
</ol>
<h2 id="标题（Header）[^Header]"><font color="red">标题（Header）</font>[^Header]</h2><p>标题用于呈现文档组织结构，很多 Markdown 解析器都提供基于 Heading Levels 来生成文档大纲的 <code>[TOC]</code>（Table of Contents）标签，搜索引擎则使用标题为网页的结构和内容编制索引。<br>一般论文或博客文档结构到3到4级即可，可参考《<a href="http://www.zaojiance.com/news/news-detail-2013-10-09-23-55.html" target="_blank" rel="external">毕业论文的国家标准格式与通用格式</a>》、《<a href="http://wenku.baidu.com/link?url=CCLjLN3lGmNVU6_TlAiTgSXZKNObnmFPEKuVXIw8OanlNhzy7vWhu-r-ekzb7GjUGoHKfnFehrClNFbB3yCgcOcJqVYYMuTfddxjw5gIPse" target="_blank" rel="external">发表论文通用格式</a>》和《<a href="http://biyelunwen.yjbys.com/geshi/417273.html" target="_blank" rel="external">期刊论文格式</a>》。</p>
<p>Markdown 支持两种标题的语法，类 <a href="http://docutils.sourceforge.net/mirror/setext.html" target="_blank" rel="external">Setext</a> 和类 <a href="http://www.aaronsw.com/2002/atx/" target="_blank" rel="external">atx</a> 形式。</p>
<h3 id="Setext_Heading_Format（2_level）">Setext Heading Format（2 level）</h3><p>类 Setext 形式是用底线的形式，使用三个或以上连续 = 底线标记最高阶标题，使用三个或以上连续 - 底线标记第二阶标题。例如：</p>
<ol>
<li><p>equal signs for first-level headers:</p>
<h1 id="This_is_an_H1"> This is an H1</h1></li>
<li><p>dashes for second-level headers:</p>
<h2 id="This_is_an_H2"> This is an H2</h2></li>
</ol>
<h3 id="Atx_Heading_Format（6_level）">Atx Heading Format（6 level）</h3><p>类 Atx 形式则是在行首插入 1 到 6 个 # （hash character），对应 6 阶标题（对应 HTML 中的 <code>&lt;h1&gt;</code> - <code>&lt;h6&gt;</code> 标签）。例如：</p>
<pre><code><span class="preprocessor"># 这是一级标题（H1，通常用于文档标题）  </span>
<span class="preprocessor">## 这是二级标题（H2，渲染器会自动添加 hr 底线）  </span>
<span class="preprocessor">### 这是三级标题（H3）  </span>
<span class="preprocessor">#### 这是四级标题（H4）  </span>
<span class="preprocessor">##### 这是五级标题（H5）#####  </span>
<span class="preprocessor">###### 这是六级标题（H6）######</span>
</code></pre><p>为兼容和阅感起见，建议最后一个 <code>#</code> 号和标题之间加插一个空格。<br>行首的 <code>#</code> 号个数决定标题阶数，行中（末）的 <code>#</code> 号则被视作普通字符。<br>为美观起见，你也可以选择性地「闭合」类 atx 样式的标题，在行尾加上对应或不限数量的 # 号。</p>
<h2 id="句段（Sentence_/_Paragraph）">句段（Sentence / Paragraph）</h2><h3 id="换行">换行</h3><p>标准 Markdown 不支持自然换行（literal new line），有些扩展的 Markdown Render 支持自然换行。<br><code>#</code> 号标识的 Heading（H1-H6） 会自然换行，普通句段之间若要强制换行（Manual Line Break），可以在自然换行行尾追加两个（或以上）空格来实现。<br>由于不同的 Markdown Editor 的 Rendering 效果不一，建议按照标准 Markdown 书写，这样发布到不同的渲染引擎下才能取得最优的兼容性。例如：你可能需要在两行连续的以 <code>&gt;</code> 开头的引用之间加入两个空格硬换行来避免粘连；在某些 Markdown Editor 中，你可能需要在 bullet list item 行尾追加两个空格硬换行来续接后面的混合编排。</p>
<p><strong>适时内嵌 HTML 的 <code>&lt;br&gt;</code> 控制换行</strong></p>
<blockquote>
<p>由于空格在 Markdown 中主要是起着控制排版的作用，因此在某些复杂的区块元素中，例如下文提到的 Table 表格中的 td 元素文本中，只能通过内嵌 HTML 的<code>&lt;br&gt;</code>（XHTML 自闭合写作 <code>&lt;br /&gt;</code>）标签来实现局部换行。</p>
</blockquote>
<h3 id="分段">分段</h3><p>段落是由一个或多个连续的文本行组成，它的前后往往需要<strong>空行</strong>予以明示分隔。</p>
<blockquote>
<p>在显示上看起来像是空的，例如只包含空格或（和）制表符（tab）的行，便会被视为空行。</p>
</blockquote>
<p><strong>空行适用场景说明：</strong></p>
<ol>
<li>空行的上一句末无需再添加两个空格或 <code>&lt;br/&gt;</code> 换行了。  </li>
<li>句段之间引入空行，相当于间隔成段落（对应 HTML 的 <code>&lt;p&gt;</code> 标签）。  </li>
<li>尽管 Markdown Render 会对各阶 Heading（H1-H6）有特殊的格式渲染来凸显层级，但还是建议在章节（Section/Chapter）末尾适时插入空行，以示行文分割且方便阅读。  </li>
<li>为了更优的 <em>阅读感</em> 和 <em>兼容性</em>，建议在分割线（Horizontal Rules）的上面留一空行，块引用（Blockquote）、预格式化（Preformatted Code Block）、列表（List）、表格（Table）等区块元素的上下各插入空行。</li>
</ol>
<h2 id="符号（Punctuation_Characters）">符号（Punctuation Characters）</h2><h3 id="转义字符">转义字符</h3><p>Markdown 精挑细选了一些符号组成了一套基于文本的标记语法。比如：</p>
<ul>
<li>在文字两旁加上 * 号，看起来就像*强调*。</li>
<li>多行行首添加 +（或 - 或 *），看起来就是列表。</li>
<li>句段行首添加 &gt; 号来引用区块，就像你曾在电子邮件中见过的那样。</li>
</ul>
<p>可以使用反斜杠（\，backslash）转义输入 Markdown 标记符号的原义字符。  </p>
<hr>
<p>#：行首的 <kbd>#</kbd> 号默认为H1，这里使用反斜杠转义显示原义字符。  </p>
<h3 id="字符实体">字符实体</h3><p>在 Markdown 中，空格和 tab 往往用于格式控制，例如：</p>
<ul>
<li>行首插入 tab 或 四个空格缩进表示 <code>&lt;pre&gt;</code> 预格式化；</li>
<li>引用、列表的 bullet 标记符前的 tab 或 空格 用于缩进嵌套层级；</li>
<li>…</li>
</ul>
<p>普通段落一般都是顶格开始，无法使用空格或 tab 来缩进，包括引用标记符（&gt;）、列表标记符（bullet list indicator）后面的空格都无法实现缩进。<br>如果硬要输入空格显示占位缩进效果，可以嵌入空格对应的 <a href="http://114.xixik.com/character/" target="_blank" rel="external">HTML Entity</a> 实体码。HTML 转义字符串（Escape Sequence），即字符实体（Character Entity）。字符实体由三部分构成：</p>
<ol>
<li>第一部分是一个 <code>&amp;</code> （ampersand）符号；</li>
<li>第二部分是实体（Entity）名字，或者是 <code>#</code> 加上实体编号（<a href="http://entity-lookup.leftlogic.com/" target="_blank" rel="external">Entity Code</a>）；</li>
<li>第三部分是一个分号 <code>;</code> （semicolon）。</li>
</ol>
<hr>
<p>  普通自然行行首敲2个空格无占位缩进效果。<br>&nbsp;&nbsp;&#160;&#160;该行行首添加了4个不断行的空白格：no-break space(<code>&amp;nbsp;</code>或<code>&amp;#160;</code>）<br>&ensp;&ensp;&ensp;&ensp;该行行首添加了4个半方大的空白：en space（<code>&amp;ensp;</code>或<code>&amp;#8194;</code>）<br>&emsp;&emsp;&#8195;&#8195;该行行首添加了4个全方大的空白：em space（<code>&amp;emsp;</code>或<code>&amp;#8195;</code>）</p>
<h2 id="分隔线（Horizontal_Rules）">分隔线（Horizontal Rules）</h2><p>你可以在一行中用三个以上的星号（asterisks：*）或减号（hyphens：-）或底线（underscores：_）来建立一个水平分隔线，对应 HTML 中的 <code>&lt;hr&gt;</code> 标签，用于Sentence/Section/Page Break。<br>行内不能有其他东西，但你可以在星号或是减号中间插入空格。<br>下面每种写法都可以建立起分隔线：</p>
<pre><code><span class="bullet">---
</span><span class="header">- - -
-----</span>
</code></pre><p><strong>注意：</strong></p>
<blockquote>
<p>采用减号（-）分割时，最好空格隔开或上面空一行，不然三个以上连续的减号会误将上一行文字升级为二级标题！</p>
</blockquote>
<h2 id="文本格式（Text_Styling）">文本格式（Text Styling）</h2><p>文本格式包括强调、加粗、突出、下划线、删除线、脚标等增强修饰和丰富表现。</p>
<h3 id="强调（Italic/Emphasize）">强调（Italic/Emphasize）</h3><p><strong>说明：</strong><br>星号（*）或下划线（_）包围的文字将会显示斜体，对应 HTML 中的 <code>&lt;i&gt;</code> / <code>&lt;em&gt;</code> 标签。</p>
<p><strong>语法：</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Some of these words <span class="emphasis">*are emphasized*</span>.</span><br><span class="line">Some of these words <span class="emphasis">_are emphasized also_</span>.</span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong><br>Some of these words <em>are emphasized</em>.<br>Some of these words <em>are emphasized also</em>.</p>
<p><strong>GFM（<a href="https://help.github.com/articles/github-flavored-markdown/" target="_blank" rel="external">Github Flavored Markdown</a>）建议：</strong></p>
<blockquote>
<p>鉴于C语言等源码中，通常采用下划线定义变量，因此 GFM 忽略单词内的下划线，同时建议使用星号（*）来包裹斜体。</p>
<blockquote>
<p>下划线闭包单词斜体：wow <em>great</em> stuff (源码：<code>wow _great_ stuff</code>)<br>GFM 忽略单词内的下划线：wow_great_stuff</p>
</blockquote>
</blockquote>
<h3 id="加粗（Bold/Strong）">加粗（Bold/Strong）</h3><p><strong>说明：</strong><br>两个星号（**）或下划线（__）包围的需要特别强调的文字将会加粗显示，对应 HTML 中的 <code>&lt;b&gt;</code> / <code>&lt;strong&gt;</code> 标签。</p>
<p><strong>语法：</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">Use two asterisks for <span class="strong">**strong emphasis**</span>.</span><br><span class="line">Or, if you prefer, <span class="strong">__use two underscores instead__</span>.</span><br><span class="line">A <span class="strong">***section surrounded with three asterisks**</span>* will be  specially emphasized.</span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong><br>Use two asterisks for <strong>strong emphasis</strong>.<br>Or, if you prefer, <strong>use two underscores instead</strong>.<br>A <strong><em>section surrounded with three asterisks</em></strong> will be  specially emphasized.</p>
<h3 id="突出（Mark/Highlight）">突出（Mark/Highlight）</h3><p><strong>说明：</strong><br>在 HTML 中，可以使用 <code>&lt;mark&gt;</code> 标签来高亮显示文字，以达到醒目的目的。<br>标准 markdown 没有提供对应的标签支持，Macdown 和 Haroopad 均使用两个等号（equal signs：=）包围来突出高亮显示。</p>
<p><strong>语法：</strong><br>Macdown 和 Haroopad：<code>==Highlight==</code><br><a href="http://www.criticmarkup.com/" target="_blank" rel="external">CriticMarkup</a>语法：<code>{==Highlight==}</code></p>
<p><strong>示例：</strong><br>Macdown 和 Haroopad：==Highlight==</p>
<h3 id="下划线（Underline）">下划线（Underline）</h3><p><strong>说明：</strong><br>在 HTML 中，可以使用 <code>&lt;u&gt;</code> 标签来为文本添加下划线。<br>标准 markdown 没有提供对应的标签支持，MMD（<a href="http://fletcherpenney.net/multimarkdown/" target="_blank" rel="external">MultiMarkdown</a>）提供了扩展支持。<br>Macdown 使用星号表示强调，使用下划线表示下划线原义；Haroopad 则使用两个加号（plus sign：+）来标记下划线。</p>
<p><strong>语法：</strong><br>Macdown：<code>_underline_</code><br>Haroopad：<code>++underline++</code></p>
<p><strong>示例：</strong><br>Macdown：<em>underline</em><br>Haroopad：++underline++</p>
<h3 id="删除线（Strikethrough）">删除线（Strikethrough）</h3><p><strong>说明：</strong><br>在 HTML 中，可以使用 <code>&lt;del&gt;</code> 标签来定义文档中已被删除的文本（配合 <code>&lt;ins&gt;</code> 标签来描述文档中的更新和修正）。<br>标准 markdown 没有提供对应的标签支持，GFM 提供了扩展支持，使用两个波浪符号（two wavy line:~~）包围来给文本添加删除线。</p>
<p><strong>语法：</strong></p>
<pre><code>~~Strikethrough~~
</code></pre><p><strong>示例：</strong><br><del>Strikethrough</del></p>
<h3 id="脚标（Script）">脚标（Script）</h3><p>标准 Markdown 不支持脚标，只能通过内嵌 HTML 的<code>&lt;sup&gt;</code>和<code>&lt;sub&gt;</code>标签来实现。</p>
<h4 id="上脚标：">上脚标：</h4><p>Haroopad 语法（Caret）：<code>^Superscript^</code><br>HTML 语法：<code>&lt;sup&gt;superscript&lt;/sup&gt;</code></p>
<p><strong>示例：</strong><br>2^10^ = 2<sup>10</sup> = 1024;</p>
<h4 id="下脚标：">下脚标：</h4><p>Haroopad 语法：<code>~Subscript~</code><br>HTML 语法：<code>&lt;sub&gt;subscript&lt;/sub&gt;</code></p>
<p><strong>示例：</strong><br>H~2~O = H<sub>2</sub>O is a liquid.</p>
<h2 id="链接（Hyperlink）">链接（Hyperlink）</h2><h3 id="自动链接（Autolink）">自动链接（Autolink）</h3><p>当我们在书写一个网址时，有些 Markdown Render 能自动生成标题（title）与网址（href URL）一致的链接，这种链接也即<strong>自动链接</strong>。<br>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要用尖括号包起来的文字， Markdown 就会自动把它转化成链接。<br>对于 HTTP(s) 协议开头的超链接地址，甚至无需添加尖括号明示，也会生成自动链接。  </p>
<p><a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="external">http://daringfireball.net/projects/markdown/</a></p>
<h3 id="文字（text_href）">文字（text href）</h3><p>Markdown 支持两种形式的超文本链接语法格式： 行内式（Inline）和参考式（Reference）两种形式。<br>不管是哪一种，链接文字都是用方括号（square brackets：[]）来标记。  </p>
<h4 id="行内式（Inline）">行内式（Inline）</h4><p>只要在方块括号后面紧接着圆括号（parenthesis or round brackets）并插入链接网址即可在一行内构建链接，其语法格式为<code>[text](url)</code>，HTML 等效源码为 <code>&lt;a href=&quot;url&quot;&gt;text&lt;/a&gt;</code>。<br>如果是要链接到本机资源，可以使用相对路径（./path/to/your/resource）。</p>
<p>以下定义了一个指向 Daring Fireball Markdown 首页的超链接：</p>
<hr>
<p><code>[Daring Fireball Markdown](http://daringfireball.net/projects/markdown/)</code><br><a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="external">Daring Fireball Markdown</a></p>
<hr>
<p>如果你还想要加上链接的 title ，只要在网址后面用双引号把 title 文字包起来即可。</p>
<hr>
<p><code>[Daring Fireball Markdown](http://daringfireball.net/projects/markdown/ &quot;Markdown Official Website&quot;)</code><br><a href="http://daringfireball.net/projects/markdown/" title="Markdown Official Website" target="_blank" rel="external">Daring Fireball Markdown</a></p>
<hr>
<p>将鼠标悬停在超链接文本上将会提示 “Markdown Official Website”。</p>
<h4 id="参考式（Reference）">参考式（Reference）</h4><p>参考式的链接是在链接文字的括号后面再接上另一个方括号，在第二个方括号里面填入用以辨识链接的标记id，然后在其他地方给出该标记id真正的链接地址。</p>
<hr>
<ol>
<li>先定义参考refid：<code>[text][refid]</code>  </li>
<li>再定义refid所指：<code>[refid]:URL</code></li>
</ol>
<hr>
<p>以下参考间接定义指向 Daring Fireball Markdown 首页的超链接：</p>
<hr>
<ol>
<li>先定义参考id为markdown_homepage_refid：<br><code>[Daring Fireball Markdown][markdown_homepage_refid]</code>  </li>
<li>再在其他地方定义markdown_homepage_refid指向的URL：<br><code>[markdown_homepage_refid]:http://daringfireball.net/projects/markdown/</code>  </li>
<li>最终效果同行内式：<br><a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="external">Daring Fireball Markdown</a>  </li>
</ol>
<hr>
<p><strong>说明：</strong></p>
<ol>
<li>你也可以选择性地在两个方括号中间加上一个空格：<code>[text] [refid]</code>。由于 Markdown 不支持自然换行，将两个方括号在连续两行书写也是没问题的。中间用空行隔开，则被认为是两条精简格式的参考链接。    </li>
<li>refid 可以与 text 一致，从而进一步精简参考链接的书写格式：    <ul>
<li>此时 <code>[refid]</code> 中的 refid 可以省略置空为 <code>[]</code> ：先定义 <code>[text][]</code> ，再定义 <code>[text]:URL</code> 。</li>
<li>你甚至可以将 <code>[text][]</code> 中的空中括号也省掉不写，进一步简写为 <code>[text]</code> ，后面再定义 <code>[text]:URL</code> 。  </li>
</ul>
</li>
<li>refid 所指 href URL 在文件任意处给出定义即可。<code>[refid]:URL</code> 的 URL 后面可以选择性地用单引号、双引号或是括弧闭包起来标记 title。<br> 下面这三种链接的定义都是相同的：<br> <code>[foo]: http://example.com/  &quot;Optional Title Here&quot;</code><br> <code>[foo]: http://example.com/  &#39;Optional Title Here&#39;</code><br> <code>[foo]: http://example.com/  (Optional Title Here)</code></li>
</ol>
<h3 id="图片（image_href）">图片（image href）</h3><h4 id="插入图片">插入图片</h4><p>Markdown 使用一种和文本链接很相似的语法来插入图片，同样也允许两种样式： 行内式和参考式。<br>不同的是，需要在链接文字方括号之前添加一个感叹号（exclamation mark：!），其语法格式为 <code>![alt_text](url)</code>，HTML 等效源码为 <code>&lt;img src=&quot;url&quot; alt=&quot;text&quot; /&gt;</code>，其中alt_text可以置空。  </p>
<hr>
<p>daringfirefall logo:<br><code>![daringfirefall](http://daringfireball.net/graphics/logos/)</code><br><img src="http://daringfireball.net/graphics/logos/" alt="daringfirefall" title="daringfirefall"></p>
<p>当然，你也可以像文字链接那样添加 title 以供鼠标悬停提示。</p>
<p><strong>说明：</strong><br>Markdown 中的段落（包括图片）默认顶格左对齐，若要将图片居中，可以直接内嵌 HTML 的 <code>&lt;img&gt;</code> 标签，设置<code>align=&quot;middle&quot;</code>。如果还不行，可以尝试封裹一层 div 设置 <code>style=&quot;text-align:center&quot;</code> 实现：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">"text-align:center"</span>&gt;</span><span class="tag">&lt;<span class="title">img</span> <span class="attribute">src</span>=<span class="value">"http://my.csdn.net/uploads/avatar/9/D/B/1_phunxm.jpg"</span> <span class="attribute">align</span>=<span class="value">"middle"</span>  <span class="attribute">alt</span>=<span class="value">"程序猿-弦苦"</span> /&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<div style="text-align:center"><img src="http://my.csdn.net/uploads/avatar/9/D/B/1_phunxm.jpg" align="middle" alt="程序猿-弦苦"></div>

<h4 id="图片链接">图片链接</h4><p>如果拷贝了别人的图片插入到自己的博客中，最好在图片上给出一个超链接指向源头，方便追溯出处。<br>我们在 Markdown 图片标记<code>![]()</code>外面再嵌套一层<code>[]()</code>即可建立图片超链接，点击图片即可跳转到链接地址。<br>图片链接的格式看起来大概是这样的:<br><code>[![](img_url)](ref_url)</code></p>
<hr>
<p>定义 haroopad logo 指向首页：<br><code>[![](http://pad.haroopress.com/assets/images/logo-small.png &quot;haroopad&quot;)](http://pad.haroopress.com/)</code></p>
<p><a href="http://pad.haroopress.com/" target="_blank" rel="external"><img src="http://pad.haroopress.com/assets/images/logo-small.png" alt="" title="haroopad"></a></p>
<h3 id="锚点（inner_link）">锚点（inner link）</h3><h4 id="书签（Bookmark）">书签（Bookmark）</h4><p>HTML 中的 <code>&lt;a&gt;</code> 标签最重要的属性是 href ，它指示的链接目标，既可以是外部站点，也可以是页内锚点。页内锚点可以实现类似书签跳转的功能，最典型的就是点击 TOC 中的目录书签跳转到指定章节阅读。<br>构建页内锚点的语法，类似参考式链接：</p>
<hr>
<ol>
<li>先定义锚点id：<code>&lt;a href=&quot;#auchor_id&quot;&gt;bookmark_text&lt;/a&gt;</code>  </li>
<li>再定义一个id为auchor_id的对象（这里以<code>&lt;p&gt;</code>为例）：<code>&lt;p id=&quot;auchor_id&quot;&gt;auchor_text&lt;/p&gt;</code></li>
</ol>
<hr>
<p>例如，我们在文末定义了id为end的 EOF（End Of File）：<code>&lt;p id=&quot;end&quot;&gt;The end！&lt;/p&gt;</code>，然后通过<code>&lt;a href=&quot;#end&quot;&gt;Goto the End!&lt;/a&gt;</code>指定书签“Goto the End!”跳转到文末“The End!”处：</p>
<p><a href="#end">Goto the End!</a></p>
<h4 id="脚注（Footnote）">脚注（Footnote）</h4><p>上面我们定义了书签 <code>Goto the End!</code> ，点击该书签将跳转到文末 id 为 <code>#end</code> 的锚点，使得我们能快速翻到文末。那怎么再跳转回刚才书签所在的阅读点呢？下面来介绍一下具备回环跳转效果的脚注。</p>
<p><strong>脚注</strong>用于为正文中的某个条目添加补充注释，对词条的引文出处进行标注或对专业术语予以解释，跟参考文献一样。脚注一般位于文档的末尾，文内则以数字标注。</p>
<p>脚注的写法和极简参考式链接书写格式比较类似：</p>
<hr>
<ol>
<li>先在需要脚注的单词（terminology）后面添加 <code>[^Footnote]</code> ： <code>terminology[^Footnote]</code></li>
<li>再在文末 glossary 区域定义脚注（添加注解）： <code>[^Footnote]：explanatory notes</code></li>
</ol>
<hr>
<p>以下是本文针对第二章标题 “标题（Header）”的着色添加的脚注：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="header">## &lt;font color='red'&gt;标题（Header）&lt;/font&gt;[^Header]</span></span><br><span class="line"></span><br><span class="line">[<span class="link_reference">^Header</span>]:<span class="link_url">这里的源码为`&lt;font color='red'&gt;标题（Header）&lt;/font&gt;`，尝试使用 font.color 着色。</span></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<blockquote>
<ol>
<li>被添加脚注的词条后面会出现一个超链接数字（有的渲染为上标格式），点击数字跳转到文末 glossary 区域该脚注的定义处。  </li>
<li>文末 glossary 区域该脚注定义的行尾会添加一个回车符号（&crarr;），点击可回到被标注的脚注点。</li>
</ol>
</blockquote>
<h2 id="引用（Blockquote）">引用（Blockquote）</h2><p>HTML 中的 <code>&lt;blockquote&gt;</code> 标签定义摘自另一个源的块引用。<br><code>&lt;blockquote&gt;</code> 与 <code>&lt;/blockquote&gt;</code> 之间的所有文本都会从常规文本中分离出来，经常会在左右两边进行<strong>缩进</strong>，而且有时会使用<strong>斜体</strong>。也就是说，块引用拥有它们自己的<u>空间</u>。本文大量使用引用（复合列表）来标识特殊说明或注意事项。</p>
<p>Markdown 标记区块引用是使用类似 email 的引用方式，在断好的行前加上 <code>&gt;</code> （more than or greater than sign）：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="blockquote">&gt; 爱上一个人  </span></span><br><span class="line"><span class="blockquote">&gt; 恋上一座城</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>爱上一个人<br>恋上一座城</p>
</blockquote>
<hr>
<p>行首的多重引用标记可以实现嵌套缩进效果（注意解梦时需要空行出梦）：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="blockquote">&gt; 梦</span></span><br><span class="line">&gt;&gt; 梦中梦</span><br><span class="line">&gt;&gt;&gt; 盗梦空间</span><br><span class="line"><span class="blockquote">&gt;</span><br><span class="line">&gt;&gt; 梦中梦</span></span><br><span class="line"></span><br><span class="line"><span class="blockquote">&gt; 梦</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>梦</p>
<blockquote>
<p>梦中梦</p>
<blockquote>
<p>盗梦空间</p>
</blockquote>
<p>梦中梦</p>
</blockquote>
<p>梦</p>
</blockquote>
<p><strong>说明：</strong></p>
<blockquote>
<ol>
<li>若使用引用格式插入代码，行首的缩进格式丢失，需要自行补充空格占位符。  </li>
<li>一般不建议使用 blockquote（<code>&gt;</code>）格式引用源代码，应采用 pre 格式引用代码。  </li>
<li>嵌套深入浅出时，需要添加空行（blank line）或者空引用行（additional levels of >）。</li>
</ol>
</blockquote>
<h2 id="代码（Code）">代码（Code）</h2><p>如果要标记行内代码片段，可以用<strong>反引号</strong>（backtick quotes）闭包；如果要插入跨行片段或块，可使用<strong>预格式化</strong>语法。<br>本文在示范 Markdown 语法源码时，独行单句采用了行内代码格式，跨行代码片段则采用了代码块格式。</p>
<h3 id="行内代码（Inline_Code）">行内代码（Inline Code）</h3><p><strong>说明：</strong></p>
<p>如果要标记行内代码片段，可以用反引号（backtick quotes）包裹，对应 HTML 中的 <code>&lt;code&gt;</code> 标签（把文本变成等宽字体，暗示是源程序代码）。<br>如果要在代码区段内插入反引号，可以用多个反引号来开启和结束代码区段。  </p>
<p><strong>语法：</strong></p>
<p>Use the `printf()` function.(此处使用了反斜杠转义)</p>
<p><strong>示例：</strong></p>
<p>Use the <code>printf()</code> function.(`printf()`)<br>Use the<code>`printf()` </code>function.(`` `printf()` ```)</p>
<h3 id="代码块（Code_Blocks）">代码块（Code Blocks）</h3><p><strong>说明：</strong></p>
<ul>
<li>Preformatted Code Block<br>  如果要插入跨行片段或块，且要保持排版样式（包括空格、换行符和缩进），可使用<strong>预格式化</strong>引用语法格式。对应 HTML 中的 <code>&lt;pre&gt;</code> 标签。  </li>
<li>Fenced Code Block<br>  如果要支持编程语言语法高亮，则可以使用 GFM 扩展的基于 YAML[^YAML] 标记语言的 Fenced Code Block 引用语法格式。</li>
</ul>
<p><strong>语法：</strong></p>
<ul>
<li>Preformatted Code Block<br>  在句段的行首插入1个 tab 或4个空格，则表示代码块。  </li>
<li>[Fenced Code Block]<br>  在句段行首和行末用三个反引号换行闭包，并在行首三个反引号后添加 <a href="https://github.com/github/linguist/blob/master/lib/linguist/languages.yml" target="_blank" rel="external">YAML</a> 语言标识。</li>
</ul>
<table>
<thead>
<tr>
<th>language</th>
<th>aliases</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Markdown</code></td>
<td>无别名，注意区分大小写</td>
</tr>
<tr>
<td><code>HTML</code></td>
<td><code>xhtml</code></td>
</tr>
<tr>
<td><code>JavaScript</code></td>
<td><code>js</code>、<code>node</code></td>
</tr>
<tr>
<td><code>C</code></td>
<td>无别名，注意区分大小写</td>
</tr>
<tr>
<td><code>C++</code></td>
<td><code>cpp</code></td>
</tr>
<tr>
<td><code>Objective-C</code></td>
<td><code>obj-c</code>、<code>objc</code>、<code>objectivec</code></td>
</tr>
<tr>
<td><code>VimL</code></td>
<td><code>vim</code>、<code>nvim</code></td>
</tr>
</tbody>
</table>
<p><strong>示例：</strong></p>
<hr>
<p><strong>1.Preformatted Code Block</strong></p>
<p>将一段代码块整体向右缩进（<kbd>⌘</kbd> + <kbd>]</kbd>）即可测试。</p>
<p>（1）以tab开头：</p>
<pre><code>these lines <span class="operator"><span class="keyword">begin</span> <span class="keyword">with</span> tab will be shown <span class="keyword">as</span> pre code <span class="keyword">block</span>.
these <span class="keyword">lines</span> <span class="keyword">begin</span> <span class="keyword">with</span> tab will be shown <span class="keyword">as</span> pre code <span class="keyword">block</span>.
these <span class="keyword">lines</span> <span class="keyword">begin</span> <span class="keyword">with</span> tab will be shown <span class="keyword">as</span> pre code <span class="keyword">block</span>.</span>
</code></pre><p>（2）以四个空格开头：</p>
<pre><code>these lines <span class="operator"><span class="keyword">begin</span> <span class="keyword">with</span> <span class="number">4</span> spaces will also be shown <span class="keyword">as</span> pre code <span class="keyword">block</span>.
these <span class="keyword">lines</span> <span class="keyword">begin</span> <span class="keyword">with</span> <span class="number">4</span> spaces will also be shown <span class="keyword">as</span> pre code <span class="keyword">block</span>.
these <span class="keyword">lines</span> <span class="keyword">begin</span> <span class="keyword">with</span> <span class="number">4</span> spaces will also be shown <span class="keyword">as</span> pre code <span class="keyword">block</span>.</span>
</code></pre><p><strong>注意：</strong></p>
<blockquote>
<p>pre 格式存在以下缺陷：</p>
<ul>
<li>对多tab及空格的缩进支持不完善！</li>
<li>将宏符号#（#include、#import）误解为H1，可能会影响解析器的TOC！</li>
<li>将顶格空白行（包括行首带tab）误认为Paragraph Break，而割断代码块成片段！</li>
</ul>
</blockquote>
<hr>
<p><strong>2.Fenced Code Block</strong></p>
<p>Fenced Code Block 以三个反引号（backtick quotes：`，有的支持波浪线~）包裹，第一行的三个反引号之后可以冠上编程语言的 YAML 标记识别语法高亮。</p>
<ul>
<li>以下演示插入一句 python 代码：</li>
</ul>
<blockquote>
<p>首行：```python<br>中间：print(‘Hello world!’)<br>末行：```</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'Hello world!'</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>以下演示插入一段 Objective-C 代码：</li>
</ul>
<blockquote>
<p>首行：```obj-c<br>中间：Objective-C Code Block<br>末行：```</p>
</blockquote>
<figure class="highlight obj-c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  main.m</span></span><br><span class="line"><span class="comment">//  EmptyApplication</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Created by faner on 15/9/5.</span></span><br><span class="line"><span class="comment">//  Copyright © 2015年 faner. All rights reserved.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="preprocessor">#import <span class="title">"AppDelegate.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">	<span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate class]));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<blockquote>
<ol>
<li>Haroopad 编辑器将上述代码中的<code>#import</code>的第一个有效字符<code>#</code><a href="https://github.com/rhiokim/haroopad/issues/536" target="_blank" rel="external">误解为 H1</a>，导致 TOC 错乱或  Heading Focus Folding 失效。此时，可以在Fenced Code Block 行首添加空格或 tab 缩进。</li>
<li>关于 GitHub 配置 Fenced Code Block 语法高亮所使用的 YAML 标记 ，可参考<a href="http://www.cnblogs.com/chwkai/archive/2009/03/01/249924.html" target="_blank" rel="external">初探YAML</a>、<a href="http://blog.csdn.net/conquer0715/article/details/42108061" target="_blank" rel="external">YAML学习</a>、<a href="http://www.cnblogs.com/dbasys/archive/2007/06/11/2127620.html" target="_blank" rel="external">YAML学习总结</a>、<a href="http://www.ibm.com/developerworks/cn/xml/x-1103linrr/" target="_blank" rel="external">YAML–想要爱你很容易</a>。</li>
</ol>
</blockquote>
<h2 id="列表（List）">列表（List）</h2><p>GFM 等 Markdown 扩展支持和无序列表、有序列表和任务列表。</p>
<h3 id="无序列表（Unordered_List）">无序列表（Unordered List）</h3><p>无序列表（unordered, bulleted）项目的行首使用星号（或加号，或减号）加空格作为列表标记（list markers）：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>bullet list item 1 begin with a hyphens '-'</span><br><span class="line"><span class="bullet">+ </span>bullet list item 2 begin with a pluses '+'</span><br><span class="line"><span class="bullet">* </span>bullet list item 3 begin with an asterisks '*'</span><br></pre></td></tr></table></figure>
<p>示例效果：</p>
<ul>
<li>bullet list item 1 begin with a ‘-‘</li>
</ul>
<ul>
<li>bullet list item 2 begin with a ‘+’</li>
</ul>
<ul>
<li>bullet list item 3 begin with a ‘*’</li>
</ul>
<p>通过在列表标记前面增加 tab 阶次可以实现嵌套效果（nested list）。<br>以下是针对本文 TOC 中【链接】这一章节的目录：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>链接（Hyperlink）</span><br><span class="line"><span class="code">	- 自动链接（Autolink） &lt;!--行首缩进1个tab--&gt;</span></span><br><span class="line"><span class="code">	- 文字（text href）</span></span><br><span class="line"><span class="code">		- 行内式（Inline） &lt;!--行首缩进2个tab--&gt;</span></span><br><span class="line"><span class="code">		- 参考式（Reference）</span></span><br><span class="line"><span class="code">	- 图片（image href）</span></span><br><span class="line"><span class="code">		- 插入图片</span></span><br><span class="line"><span class="code">		- 图片链接</span></span><br><span class="line"><span class="code">	- 锚点（inner link）</span></span><br><span class="line"><span class="code">		- 书签（Bookmark）</span></span><br><span class="line"><span class="code">		- 脚注（Footnote）</span></span><br><span class="line"><span class="bullet">- </span>引用（Blockquote）</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>链接（Hyperlink）<ul>
<li>自动链接（Autolink）</li>
<li>文字（text href）<ul>
<li>行内式（Inline）</li>
<li>参考式（Reference）</li>
</ul>
</li>
<li>图片（image href）<ul>
<li>插入图片</li>
<li>图片链接</li>
</ul>
</li>
<li>锚点（inner link）<ul>
<li>书签（Bookmark）</li>
<li>脚注（Footnote）</li>
</ul>
</li>
</ul>
</li>
<li>引用（Blockquote）</li>
</ul>
<p><strong>缩进控制符：空格 or TAB？</strong></p>
<blockquote>
<ol>
<li>在列表标记前面插入空格也可以实现缩进控制嵌套效果，但不同的 Markdown Render 对控制层级的空格个数要求不一。  </li>
<li>为了取得最佳的兼容性，建议使用 <strong>tab</strong> 来控制嵌套层级（nested hierarchy），以期在不同的渲染引擎下都能达到预期的显示效果。当然，前提是使用hard tabs（tab characters），而soft tabs（spaces）。</li>
</ol>
</blockquote>
<h3 id="有序列表（Ordered_List）">有序列表（Ordered List）</h3><p>有序列表（ordered / numbered）项目的行首则使用数字接一个英文句点标记（use numbers followed by periods）：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1. </span>GETTING STARTED  </span><br><span class="line"><span class="code">	Choosing Blogging Platform (WordPress)</span></span><br><span class="line"><span class="bullet">2. </span>GETTING YOUR BLOG ONLINE  </span><br><span class="line"><span class="code">	Choosing Domain Name &amp; Web Hosting</span></span><br><span class="line"><span class="bullet">3. </span>DESIGNING AND TWEAKING YOUR BLOG  </span><br><span class="line"><span class="code">	Quick and easy ways to get your blog look the way you want</span></span><br><span class="line"><span class="bullet">4. </span>WRITING BLOG POSTS AND PAGES  </span><br><span class="line"><span class="code">	Adding new content for your Blog (Posts, Pages, Images etc…)</span></span><br></pre></td></tr></table></figure>
<p><a href="http://startbloggingonline.com/" target="_blank" rel="external">Step-by-step walkthrough for starting a blog</a>:</p>
<ol>
<li>GETTING STARTED<br> Choosing Blogging Platform (WordPress)</li>
<li>GETTING YOUR BLOG ONLINE<br> Choosing Domain Name &amp; Web Hosting</li>
<li>DESIGNING AND TWEAKING YOUR BLOG<br> Quick and easy ways to get your blog look the way you want</li>
<li>WRITING BLOG POSTS AND PAGES<br> Adding new content for your Blog (Posts, Pages, Images etc…)</li>
</ol>
<p>有序列表和无序列表可以实现混合嵌套编排。</p>
<h3 id="任务列表（Task_Lit）">任务列表（Task Lit）</h3><p>GFM 扩展支持把列表变成带勾选框的任务列表，只需要在列表标记后添加<code>[ ]</code>标记☐表示unchecked，在中括号中填写x（<code>[x]</code>）标记☑︎表示checked（filled）。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>[ ] task1 to do</span><br><span class="line"><span class="bullet">- </span>[x] task2 done</span><br><span class="line"><span class="bullet">1. </span>[ ] task3 to do</span><br><span class="line"><span class="bullet">2. </span>[x] task4 done</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>[ ] task1 to do</li>
<li>[x] task2 done</li>
</ul>
<ol>
<li>[ ] task3 to do</li>
<li>[x] task4 done</li>
</ol>
<h2 id="表格（Table）">表格（Table）</h2><p>You can create tables by assembling a list of words and dividing them with hyphens <code>-</code> (for the first row), and then separating each column with a pipe <code>|</code> (vertical bar):</p>
<table>
<thead>
<tr>
<th>First Header</th>
<th>Second Header</th>
</tr>
</thead>
<tbody>
<tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
<tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
</tbody>
</table>
<p>For aesthetic purposes, you can also add extra pipes on the ends:</p>
<table>
<thead>
<tr>
<th>First Header</th>
<th>Second Header</th>
</tr>
</thead>
<tbody>
<tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
<tr>
<td>Content Cell</td>
<td>Content Cell</td>
</tr>
</tbody>
</table>
<p>Note that the dashes at the top don’t need to match the length of the header text exactly:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Help</td>
<td>Display the help window.</td>
</tr>
<tr>
<td>Close</td>
<td>Closes a window</td>
</tr>
</tbody>
</table>
<p>You can also include inline Markdown such as links, bold, italics, or strikethrough:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Help</td>
<td><del>Display the</del> help window.</td>
</tr>
<tr>
<td>Close</td>
<td><em>Closes</em> a window</td>
</tr>
</tbody>
</table>
<p>Finally, by including colons <code>:</code> within the header row, you can define text to be left-aligned, right-aligned, or center-aligned:</p>
<table>
<thead>
<tr>
<th style="text-align:left">Left-Aligned</th>
<th style="text-align:center">Center Aligned</th>
<th style="text-align:right">Right Aligned</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">col 3 is</td>
<td style="text-align:center">some wordy text</td>
<td style="text-align:right">$1600</td>
</tr>
<tr>
<td style="text-align:left">col 2 is</td>
<td style="text-align:center">centered</td>
<td style="text-align:right">$12</td>
</tr>
<tr>
<td style="text-align:left">zebra stripes</td>
<td style="text-align:center">are neat</td>
<td style="text-align:right">$1</td>
</tr>
</tbody>
</table>
<p>A colon on the left-most side indicates a left-aligned column; a colon on the right-most side indicates a right-aligned column; a colon on both sides indicates a center-aligned column.</p>
<h2 id="数学公式">数学公式</h2><p>You can render <em>LaTeX</em>[^LaTeX] mathematical expressions using <strong>MathJax</strong>[^MathJax], as on math.stackexchange.com:<br>The <em>Gamma function</em> satisfying $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$ is via the Euler integral</p>
<p>$$<br>\Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt\,.<br>$$</p>
<p>书写一个质能守恒公式</p>
<p>$$E=mc^2$$</p>
<p>可参考 <a href="http://mlworks.cn/posts/introduction-to-mathjax-and-latex-expression/" target="_blank" rel="external">Mathjax与LaTex公式简介</a>。</p>
<p>##<!--以下是本文的脚注和超链接--></p>
<p id="end">The end！</p>

<p>[^Header]:这里的源码为<code>&lt;font color=&#39;red&#39;&gt;标题（Header）&lt;/font&gt;</code>，尝试使用 font.color 着色。</p>
<p>[^YAML]:<a href="http://yaml.org/" target="_blank" rel="external">YAML</a>是”YAML Ain’t a Markup Language”（YAML不是一种置标语言）的递归缩写，早先YAML的意思其实是：”Yet Another Markup Language”（另外一种置标语言）。</p>
<p>[^LaTeX]: <a href="http://www.latex-project.org/" target="_blank" rel="external">LaTeX</a>是一种基于 <a href="http://www.ctex.org/documents/shredder/tex_frame.html" target="_blank" rel="external">ΤΕΧ</a>的排版系统，它通过\section和\paragraph等语句，规定了每一句话在文章中所从属的层次，从而极大方便了对各个层次批量处理。可参考 <a href="http://blog.csdn.net/dbzhang800/article/details/6820659" target="_blank" rel="external">TeX 与 LaTeX</a>、<a href="http://liam0205.me/2014/09/08/latex-introduction/" target="_blank" rel="external">LaTeX 入门文档</a> 和 <a href="http://www.douban.com/note/330524120/" target="_blank" rel="external">LaTeX 入门教程</a>。</p>
<p>[^MathJax]: <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="external">MatchJax</a> 是一个JavaScript引擎，用来显示网络上的数学公式。MathJax可以解析Latex、MathML和ASCIIMathML的标记语言。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Markdown 的目标是实现「易读易写」（easy-to-read and easy-to-write ）。<br>本文结合示例实践，系统梳理总结了 Markdown 纯文本写作标记语言的语法基础和使用过程中的诸多规范细节。<br>本文最早发表于本人 CSDN 博客 —— <a href="http://blog.csdn.net/phunxm?viewmode=list">Markdown 基础教程</a>。</p>]]>
    
    </summary>
    
      <category term="markdown" scheme="http://col.dog/tags/markdown/"/>
    
      <category term="Markdown" scheme="http://col.dog/categories/Markdown/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[git 版本控制]]></title>
    <link href="http://col.dog/2015/11/17/git-version-control/"/>
    <id>http://col.dog/2015/11/17/git-version-control/</id>
    <published>2015-11-16T23:13:23.000Z</published>
    <updated>2015-11-25T10:41:00.000Z</updated>
    <content type="html"><![CDATA[<p>之前梳理介绍过 <a href="http://blog.csdn.net/phunxm/article/details/40834427" target="_blank" rel="external">subversion 版本控制</a>，本文承接《<a href="http://blog.csdn.net/phunxm/article/details/45083335" target="_blank" rel="external">Mac下git通过SSH进行免密码安全连接github</a>》，结合具体操作实例贯串讲解 git 初级版本控制日常操作流程，备忘查阅。</p>
<a id="more"></a>
<h2 id="git_trends">git trends</h2><p><img src="http://img.blog.csdn.net/20150925231127034" alt="google trends of git"></p>
<p><img src="http://img.blog.csdn.net/20150925231200247" alt="google trends of github"></p>
<h2 id="git_for_Mac/Xcode">git for Mac/Xcode</h2><h3 id="whereis_git">whereis git</h3><p>在 Mac Terminal 中执行 <code>which</code> 或 <code>whereis</code> 命令可以查看 git 的位置：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  bin  which git&#10;/usr/bin/git&#10;&#10140;  bin  whereis git&#10;/usr/bin/git</span><br></pre></td></tr></table></figure>
<p><code>which git</code> 返回的结果是 <code>/usr/bin/git</code>，同svn一样，它们是Xcode安装 Command Line Tools 时安装的 git wrapper，或者叫 <a href="http://stackoverflow.com/questions/9329243/xcode-4-4-and-later-install-command-line-tools/" target="_blank" rel="external">shims or wrapper</a> executables，真正的工具包<strong>实体</strong>在 Xcode.app 里面：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">➜  ~  xcrun -f git</span><br><span class="line"><span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/usr/</span>bin<span class="regexp">/git</span></span><br></pre></td></tr></table></figure>
<h3 id="git_version">git version</h3><p>在终端输入 <code>git version</code> 或 <code>git --version</code> 可以查看到系统自带的 git 版本为2.3.8：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  ~  git version&#10;git version 2.3.8 (Apple Git-58)</span><br></pre></td></tr></table></figure>
<p>执行 <code>ls git*</code> 可查看 git binUtils 组成：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">➜  ~  <span class="keyword">cd</span> /usr/bin</span><br><span class="line">➜  bin  <span class="keyword">ls</span> git*</span><br><span class="line">git                git-receive-pack   git-upload-archive</span><br><span class="line">git-cvsserver      git-<span class="keyword">shell</span>          git-upload-pack</span><br></pre></td></tr></table></figure>
<h3 id="upgrade_git">upgrade git</h3><p>可从 git 官网下载 <a href="http://git-scm.com/download/mac" target="_blank" rel="external">git for Mac</a> 安装包（git-2.5.3-intel-universal-mavericks.dmg），点击 <code>git-2.5.3-intel-universal-mavericks.pkg</code> 可安装git binUtils，默认安装到 <code>/usr/local/git</code> 目录下:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  ~  cd /usr/local/git/bin&#10;&#10140;  bin git:(master) ls&#10;git                        git-receive-pack           git-upload-pack&#10;git-credential-osxkeychain git-shell                  gitk&#10;git-cvsserver              git-upload-archive</span><br></pre></td></tr></table></figure>
<ol>
<li>可在bash下运行 <code>setup git PATH for non-terminal programs.sh</code> 脚本设置新版 git 为非命令行程序的默认 git。  </li>
<li>可参照Mac下升级<a href="http://blog.csdn.net/phunxm/article/details/40834427" target="_blank" rel="external">subversion工具包升级方法</a>，直接软链新版binUtils的 git* 到<code>/Applications/Xcode.app/Contents/Developer/usr/bin</code>下即可。</li>
</ol>
<h3 id="git_manual/help">git manual/help</h3><ol>
<li>输入 <code>git</code> 或 <code>git --help</code> 可以查看 git usage，一览 <em>most commonly used git commands</em> 要义：<br> <img src="http://img.blog.csdn.net/20150908072930624" alt="git --help">  </li>
<li>针对具体 commands，可以求助“男人”（man），以下示例查看 <strong><code>git add</code></strong> 帮助的两种方式：</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  ~  git --help add&#65288;git help add&#65289;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  ~  man git add</span><br></pre></td></tr></table></figure>
<p>按 <code>q</code> 键退出 manual。</p>
<h2 id="git_config"><a href="http://blog.csdn.net/wirelessqa/article/details/8572928" target="_blank" rel="external">git config</a></h2><p>git 配置分为系统级别、用户级别和项目级别，<em><code>--global</code></em> 选项指定用户级别的配置。<br>以下配置用户 user 信息：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  ~  git config --global user.name fan2&#10;&#10140;  ~  git config --global user.email xxx@qq.com</span><br></pre></td></tr></table></figure>
<p>配置完成后，可以输入 <code>git config --list</code> 命令查看当前配置。<br>之后的 git 提交信息中将自动嵌入用户信息，即 <strong>git log</strong> 查看到的每条 log 的 Author 信息。<br>也可针对具体项目（cd 到 <code>.git</code> 所在目录）执行 <strong>git config</strong> 命令，而无需指定 <code>--system</code> 或 <code>--global</code> 选项，配置适用于<strong><em>独立项目</em></strong>的作者信息或代理信息（http.proxy）。</p>
<h2 id="git_init_repository">git init repository</h2><h3 id="cd_进入本地项目目录">cd 进入本地项目目录</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  ~  cd Projects/Xcode/resizableImageWithCapInsets</span><br></pre></td></tr></table></figure>
<p>查看当前目录：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  ~  pwd&#10;/Users/faner/Projects/Xcode/resizableImageWithCapInsets</span><br></pre></td></tr></table></figure>
<p>当前目录为空文件夹，<code>ls</code> 或 <code>ls -a</code> 列举显示无内容。</p>
<h3 id="查看当前项目（目录）的_git_状态">查看当前项目（目录）的 git 状态</h3><p>使用 <code>git status</code> 命令可以查看当前工作目录的 git 版本控制状态（增删改等）。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140; resizableImageWithCapInsets  git status&#10;fatal: Not a git repository (or any of the parent directories): .git</span><br></pre></td></tr></table></figure>
<p><code>Not a git repository</code> 表明当前工程（项目）尚未纳入 git 版本控制。</p>
<h3 id="基于当前项目（目录）初始化_git_仓库">基于当前项目（目录）初始化 git 仓库</h3><p>创建初始化 git 版本库，需要使用 <code>git init</code> 命令：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  resizableImageWithCapInsets  git init --help&#10;&#10;NAME&#10;       git-init - Create an empty Git repository or reinitialize an existing one&#10;       &#10;DESCRIPTION&#10;       This command creates an empty Git repository - basically a .git directory with&#10;       subdirectories for objects, refs/heads, refs/tags, and template files. An&#10;       initial HEAD file that references the HEAD of the master branch is also&#10;       created.</span><br></pre></td></tr></table></figure>
<p>对当前项目（目录）执行 <code>git init</code> 命令，即可初始化一个本地git仓库：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  resizableImageWithCapInsets  git init  &#10;Initialized empty Git repository in /Users/faner/Projects/Xcode/resizableImageWithCapInsets/.git/</span><br></pre></td></tr></table></figure>
<p>此时运行 <code>ls -a</code> 列举当前目录：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  resizableImageWithCapInsets git:(master) ls -a  &#10;.    ..   .git</span><br></pre></td></tr></table></figure>
<p>可以发现该目录下新增了一个隐藏的 <code>.git</code> 文件夹，它保存了 git 版本控制信息。<br>若是从 github 等远程仓库克隆（git clone）项目到本地，则默认即是一个追踪了远程仓库的 git repository，无需再执行 <code>git init</code> 初始化。</p>
<p>此时，再次执行 <strong><code>git status</code></strong> 命令可查看初始化的本地仓库状态：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  resizableImageWithCapInsets git:(master) git status&#10;On branch master&#10;&#10;Initial commit&#10;&#10;nothing to commit (create/copy files and use &#34;git add&#34; to track)</span><br></pre></td></tr></table></figure>
<p>由于当前 Git Repo 刚初始化，没有任何增删改操作，故没啥好提交的：<code>nothing to commit</code>。<br>它提示创建（create）或从别处拷贝（copy）文件过来，并调用 <strong><code>git add</code></strong> 命令添加追踪。</p>
<p><strong>说明：</strong></p>
<blockquote>
<p>下文 git 操作都是基于<em>当前工作目录</em>，即包含 <code>.git</code> 的 <strong>Working directory</strong> / <strong>Working Tree</strong>。</p>
</blockquote>
<h2 id="git_add_to_Index">git add to Index</h2><h3 id="创建第一个文件——README-md">创建第一个文件——README.md</h3><p>1.执行 <code>touch README.md</code> 命令新建 README.md 文件：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  resizableImageWithCapInsets git:(master) touch README.md&#10;&#10140;  resizableImageWithCapInsets git:(master) &#10007; ls&#10;README.md</span><br></pre></td></tr></table></figure>
<p>2.执行 <code>vi README.md</code> 打开vi（m）进行编辑：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  resizableImageWithCapInsets git:(master) &#10007; vi README.md</span><br></pre></td></tr></table></figure>
<ul>
<li><kbd>i</kbd>: 进入 insert 模式编辑;</li>
<li><kbd>Esc</kbd>: 退出insert编辑模式;</li>
<li><code>:wq</code>: 保存退出(write &amp; quit)</li>
</ul>
<p>3.编辑完成执行 <code>cat README.md</code>，可查看文件内容：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  resizableImageWithCapInsets git:(master) &#10007; cat README.md  &#10;README for resizableImageWithCapInsets.</span><br></pre></td></tr></table></figure>
<p>4.再次执行 <strong><code>git status</code></strong> 命令可查看当前本地仓库状态：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  resizableImageWithCapInsets git:(master) &#10007; git status  &#10;On branch master  &#10;&#10;Initial commit  &#10;&#10;Untracked files:  &#10;  (use &#34;git add &#60;file&#62;...&#34; to include in what will be committed)  &#10;&#10;        README.md  &#10;&#10;nothing added to commit but untracked files present (use &#34;git add&#34; to track)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Untracked files</code>，即新建的 README.md 文件未被 git 追踪（Unversioned/Untracked）。  </li>
<li><code>use &quot;git add&quot; to track</code>，提示使用 <code>git add</code> 命令将未追踪文件添加追踪（add to version control），纳入版本控制（tracked）。</li>
</ul>
<h3 id="将_README-md_文件添加到_git_index">将 README.md 文件添加到 git index</h3><p>添加本地文件到 git 版本控制，需要使用 <code>git add</code> 命令：  </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  ~  git add --help&#10;&#10;NAME&#10;       git-add - Add file contents to the index&#10;&#10;DESCRIPTION&#10;       This command updates the index using the current content found in the working&#10;       tree, to prepare the content staged for the next commit. It typically adds the&#10;       current content of existing paths as a whole, but with some options it can also&#10;       be used to add content with only part of the changes made to the working tree&#10;       files applied, or remove paths that do not exist in the working tree anymore.&#10;&#10;       The &#34;index&#34; holds a snapshot of the content of the working tree, and it is this&#10;       snapshot that is taken as the contents of the next commit. Thus after making&#10;       any changes to the working directory, and before running the commit command,&#10;       you must use the add command to add any new or modified files to the index.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>It typically adds the current content of existing paths as a whole, but with some options it can also be used to add content with <strong>only part</strong> of the changes made to the working tree files applied, or remove paths that do not exist in the working tree anymore.<br>The <strong>“index”</strong> holds a <strong>snapshot</strong> of the content of the working tree, and it is this snapshot that is taken as the contents of the next commit. <u>Thus after making <strong>any changes</strong> to the working directory, and before running the commit command, you must use the add command to add any <b><i>new</i></b> or <b><i>modified</i></b> files to the index.</u></p>
</blockquote>
<p><strong><code>index 的概念</code></strong>：</p>
<p>index 有时候也被称作 <code>Staging area</code> 或 <code>Cache</code>，<code>git add</code> 命令会将文件改动暂存到 index 中(<code>.git/index</code>)。</p>
<p><a href="http://stackoverflow.com/questions/3689838/difference-between-head-working-tree-index-in-git" target="_blank" rel="external"><img src="http://i.stack.imgur.com/naws3.png" alt="git add commit"></a></p>
<p><strong>git add 基本用法：</strong></p>
<blockquote>
<p>git add \<pathspec\></pathspec\></p>
</blockquote>
<ul>
<li><code>&lt;pathspec&gt;</code> 可以是 <code>.</code> ，表示添加当前目录下所有（<strong>as a whole</strong>）未追踪的文件或修改（unversioned/untracked files or modification）到 git 索引。  </li>
<li>也可以添加指定子目录层级的单个文件或多个文件列表（<strong>only part</strong>）。</li>
</ul>
<p><strong><code>添加 README.md 文件：</code></strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  resizableImageWithCapInsets git:(master) &#10007; git add README.md</span><br></pre></td></tr></table></figure>
<p>由于当前文件只有一个 Untracked files，因此也可执行 <code>git add .</code>。<br>再次执行<strong><code>git status</code></strong>命令可查看当前本地仓库状态：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  resizableImageWithCapInsets git:(master) &#10007; git status&#10;On branch master&#10;&#10;Initial commit&#10;&#10;Changes to be committed:&#10;  (use &#34;git rm --cached &#60;file&#62;...&#34; to unstage)&#10;&#10;  new file:   README.md</span><br></pre></td></tr></table></figure>
<p>提示有改动需要提交（Changes to be committed）：新增了文件（new file:   README.md）。</p>
<p>此时，若反悔了，想解除对 README.md 文件的追踪（Undo an Added new file），亦可执行 <code>git rm --cached</code>：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  resizableImageWithCapInsets git:(master) &#10007; git rm --cached README.md&#10;rm &#39;README.md&#39;</span><br></pre></td></tr></table></figure>
<p>则 README.md 文件又恢复到 <code>git add</code> 之前的状态——Untracked。</p>
<p><strong><code>注意</code></strong>：  </p>
<ul>
<li>执行 <code>git rm --cached README.md</code> 只是将README.md文件从暂存区（Index/Staging area）移除，文件依旧保留（keep the file）；  </li>
<li>若执行 <code>rm</code> 或 <code>git rm -f README.md</code>，则强制物理删除（force removal）本地文件。</li>
</ul>
<h2 id="git_commit_to_local_repository">git commit to local repository</h2><p>将暂存区中的变更提交到到git仓库，需要使用 <code>git commit</code> 命令：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  ~  git commit --help&#10;&#10;NAME&#10;       git-commit - Record changes to the repository&#10;&#10;DESCRIPTION&#10;       Stores the current contents of the index in a new commit along with a log&#10;       message from the user describing the changes.&#10;&#10;OPTIONS&#10;&#10;       -m &#60;msg&#62;, --message=&#60;msg&#62;&#10;           Use the given &#60;msg&#62; as the commit message. If multiple -m options are&#10;           given, their values are concatenated as separate paragraphs.</span><br></pre></td></tr></table></figure>
<p>之前在 resizableImageWithCapInsets 这个 WC（Working directory/Working tree）新增（git add）了 README.md 文件。这个 <code>git add</code> 新增变更是记录在index（staging area）中，下面将其添加到本地 git 仓库。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  resizableImageWithCapInsets git:(master) &#10007; git commit -m &#34;This is the first commit.&#34;  &#10;[master (root-commit) ee53e68] This is the first commit.  &#10;  1 file changed, 1 insertion(+)  &#10;  create mode 100644 README.md</span><br></pre></td></tr></table></figure>
<p>其中 <code>-m</code> 选项续接的双引号（” “）内容指定提交日志信息，也可以使用 <kbd>$</kbd> 续接单引号（’ ‘）支持 <code>\n</code> 换行，从而输入多行 log message lines。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  test git:(master) &#10007; git commit -m $&#39;log line 1\nlog line 2&#39;&#10;&#10;&#10140;  test git:(master) git log &#10;&#10;commit 0b9420ce187b8e8b5307b49f3b6af038847e4857&#10;Author: fan2 &#60;xxx@qq.com&#62;&#10;Date:   Tue Nov 17 07:41:42 2015 +0800&#10;&#10;    log line 1&#10;    log line 2&#10;(END)</span><br></pre></td></tr></table></figure>
<hr>
<p>commit 提交后，再次执行 <strong><code>git status</code></strong> 命令查看当前本地仓库状态：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  resizableImageWithCapInsets git:(master) git status&#10;On branch master&#10;nothing to commit, working directory clean</span><br></pre></td></tr></table></figure>
<p><code>&quot;nothing to commit, working directory clean&quot;</code> 表示变更已入库，当前工作目录是干净（clean）的。</p>
<p>执行 <code>git commit</code> 提交后，可通过 <strong><code>git log</code></strong> 命令查看提交日志：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">commit ee53e68e599695f15b8e91d5eb3fd490f945a23e  &#10;Author: fan2 &#60;xxx@qq.com&#62;  &#10;Date:   Sun Sep 13 15:34:13 2015 +0800  &#10;&#10;    This is the first commit.</span><br></pre></td></tr></table></figure>
<p>按 <code>q</code> 键退出log。</p>
<p>后续多次提交后，可通过 <a href="http://www.cnblogs.com/gbyukg/archive/2011/12/12/2285419.html" target="_blank" rel="external"><code>git log</code></a> 的 <code>-n</code> 选项（svn 中为 -l ）指定 Limit the number of commits to output，例如 <code>git log -n 2</code> 查看最近两次的提交log。</p>
<h3 id="git本地仓库">git本地仓库</h3><p>git 本地仓库由 git 维护的三棵“树”组成：</p>
<ul>
<li>第一个是 物理工作目录（Working tree），它持有实际文件；</li>
<li>第二个是 暂存区（Index），它像个缓存区域，临时保存你的改动；</li>
<li>最后是 repository，HEAD 指向你最后一次提交（commit）的结果。</li>
</ul>
<p><a href="rogerdudler.github.io/git-guide/index.zh.html"><img src="http://rogerdudler.github.io/git-guide/img/trees.png" alt="git本地仓库"></a></p>
<h2 id="git_add_modificaion_/_rm_tracked_file">git add modificaion / rm tracked file</h2><h3 id="修改文件">修改文件</h3><p>将 README.md 文件 add 添加到 git 版本控制并 commit 提交到 git 仓库后，稍微改动一下 README.md 文件：增加第二行空行，第三行增加”this is the content. “。然后，使用 <code>git diff</code> 或 <code>git diff --</code> 命令查看工作目录与索引区文件之间的差异：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  resizableImageWithCapInsets git:(master) &#10007; git diff README.md  &#10;diff --git a/README.md b/README.md  &#10;index 717aedf..0a1832d 100644  &#10;--- a/README.md  &#10;+++ b/README.md  &#10;@@ -1 +1,3 @@  &#10;&#38;nbsp;README for resizableImageWithCapInsets.  &#10;+  &#10;+this is the content.</span><br></pre></td></tr></table></figure>
<p>按 <code>q</code> 键退出 diff。</p>
<p>以上也可使用 <code>git diff HEAD</code> 命令查看工作目录与 git 仓库之间的差异。</p>
<p>再次执行 <strong><code>git status</code></strong> 命令查看当前本地仓库状态：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  resizableImageWithCapInsets git:(master) git status&#10;On branch master&#10;Changes not staged for commit:&#10;  (use &#34;git add &#60;file&#62;...&#34; to update what will be committed)&#10;  (use &#34;git checkout -- &#60;file&#62;...&#34; to discard changes in working irectory)&#10;&#10;    modified:   README.md&#10;&#10;no changes added to commit (use &#34;git add&#34; and/or &#34;git commit -a&#34;)</span><br></pre></td></tr></table></figure>
<p>提示修改了 README.md 文件（状态为 modified），但是修改没有添加到缓存（Changes not staged）。此种状态下，可以执行两种操作： </p>
<ul>
<li><code>git checkout -- &lt;file&gt;</code> ：<strong>放弃</strong>本地修改，恢复到上次 commit 完的”干净”版本<strong>Index</strong>中的文件记录。</li>
<li><code>git add &lt;file&gt;</code> ：提交更新到缓存。</li>
</ul>
<hr>
<p>执行 <strong><code>git add</code></strong> 命令可以将更改提交到暂存区（index/staging area）： </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  resizableImageWithCapInsets git:(master) &#10007; git add README.md  &#10;&#10140;  resizableImageWithCapInsets git:(master) &#10007; git status  &#10;On branch master  &#10;Changes to be committed:  &#10;  (use &#34;git reset HEAD &#60;file&#62;...&#34; to unstage)  &#10;&#10;  modified:   README.md</span><br></pre></td></tr></table></figure>
<p>正常情况下，对于通过 <b><code>git add</code></b> 添加到暂存区的变更，需进一步执行 <b><code>git commit</code></b> 提交到本地git仓库。这两步操作也可糅合为 <strong><code>git commit -a</code></strong> 命令一步到位。<code>-a</code> 选项意即 <code>all</code> ，提交所有变更。</p>
<p>在 <code>git commit</code> 提交之前，可执行 <code>git diff --cached</code> 命令查看索引区与 git 仓库之间的差异。</p>
<h4 id="git_diff">git diff</h4><p>现在来总结一下使用频率较高的 <code>git diff</code> 命令：</p>
<table>
<thead>
<tr>
<th>cmd</th>
<th>ways to check diff</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>git diff</code></td>
<td>Changes in the working tree not yet staged for the next commit</td>
</tr>
<tr>
<td><code>git diff --cached</code></td>
<td>Changes between the index and your last commit; what you would be committing if you run “git commit” without “-a” option. <br><code>--staged</code> is a synonym of <code>--cached</code>.</td>
</tr>
<tr>
<td><code>git diff HEAD</code></td>
<td>Changes in the working tree since your last commit; what you would be committing if you run “git commit -a”<br><code>git diff HEAD^</code>：比较上次提交；<br><code>git diff HEAD^ HEAD</code>：Compare the version before the last commit and the last commit. <br><code>git diff HEAD~2</code>：比较上2次提交。</td>
</tr>
</tbody>
</table>
<p>关于 <a href="http://www.gitguys.com/topics/git-diff/?lang=zh" target="_blank" rel="external">git diff</a> 命令，可参考 <a href="http://www.cnblogs.com/gbyukg/archive/2011/12/13/2286884.html" target="_blank" rel="external">git diff</a> 和 <a href="http://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html" target="_blank" rel="external">读懂 diff</a>。</p>
<p>使用 <code>git diff</code> 命令时，也可指定 difftool：</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line">➜  test git:(master) ✗ git difftool </span><br><span class="line"></span><br><span class="line"><span class="type">This</span> message is displayed because <span class="symbol">'diff</span>.tool' is not configured.</span><br><span class="line"><span class="type">See</span> <span class="symbol">'git</span> difftool --tool-help' <span class="keyword">or</span> <span class="symbol">'git</span> help config' <span class="keyword">for</span> more details.</span><br><span class="line"><span class="symbol">'git</span> difftool' will now attempt <span class="keyword">to</span> use one <span class="keyword">of</span> the following tools:</span><br><span class="line">opendiff kdiff3 tkdiff xxdiff meld kompare gvimdiff diffuse diffmerge ecmerge p4merge araxis bc codecompare emerge vimdiff</span><br><span class="line"></span><br><span class="line"><span class="type">Viewing</span> (<span class="number">1</span>/<span class="number">1</span>): <span class="symbol">'README</span>.md'</span><br><span class="line"><span class="type">Launch</span> <span class="symbol">'opendiff'</span> [<span class="type">Y</span>/n]:</span><br></pre></td></tr></table></figure>
<p>配置 <code>vimdiff</code> 作为 git difftool：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">git config --global diff.tool vimdiff</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="http://www.cnblogs.com/kangyi/p/4827078.html" target="_blank" rel="external">AraxisMerge和 Beyond Compare 做 git mergetool 配置</a>  </li>
<li><a href="http://blog.csdn.net/snowdream86/article/details/8807397" target="_blank" rel="external">Git 集成 Araxis Merge 作为比较和合并 GUI 工具的配置</a>  </li>
<li><a href="https://lautaportti.wordpress.com/2009/02/11/using-araxis-merge-with-git/" target="_blank" rel="external">Using Araxis Merge with Git</a>  </li>
<li><a href="http://stackoverflow.com/questions/14593817/how-do-i-configure-araxis-merge-for-use-with-git" target="_blank" rel="external">how-do-i-configure-araxis-merge-for-use-with-git</a></li>
</ul>
<h4 id="git_reset_HEAD">git reset HEAD</h4><p>若想放弃通过 <code>git add</code> 提交到暂存区中的修改（Unstaging a Staged File/Undo an Added new modification），可执行 <code>git reset HEAD &lt;file&gt;</code> 撤销提交到暂存中的修改：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  resizableImageWithCapInsets git:(master) &#10007; git reset HEAD README.md  &#10;Unstaged changes after reset:  &#10;M&#9;README.md</span><br></pre></td></tr></table></figure>
<p>执行 <code>git reset HEAD</code> 后，Index/Staging Area 中记录的 README.md 文件恢复恢复到上次commit 完 local repository 中的 HEAD 文件记录。Working tree中 README.md 文件的状态则恢复为 modified（Changes Unstaged relative to index），可执行 <code>git status</code> 查看最新状态。可以继续编辑 README.md 再适时提交。</p>
<h3 id="删除文件">删除文件</h3><p>将 README.md 文件添加到 git 版本控制并且提交到 git 仓库后，，可以使用 <code>git rm</code> 命令删除本地 git 仓库中的 tracked/versioned 文件：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  resizableImageWithCapInsets git:(master) git rm README.md&#10;rm &#39;README.md&#39;</span><br></pre></td></tr></table></figure>
<p>再次执行 <strong><code>git status</code></strong> 命令查看当前本地仓库状态：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  resizableImageWithCapInsets git:(master) &#10007; git status  &#10;On branch master  &#10;Changes to be committed:  &#10;  (use &#34;git reset HEAD &#60;file&#62;...&#34; to unstage)  &#10;&#10;    deleted:    README.md</span><br></pre></td></tr></table></figure>
<p>可执行 <code>git reset HEAD &lt;file&gt;</code> 撤销提交到暂存中的 <code>git rm</code> 操作（recover by local repository’s HEAD to resume unstage status），也可以进一步执行 <b><code>git commit</code></b> 提交缓存操作到本地 git 仓库生效。</p>
<hr>
<p>在正式推送到远程仓库之前，若想撤销最近一次的 commit 怎么办呢？可参考《<a href="http://www.miss77.net/804.html" target="_blank" rel="external">git 撤销commit</a>》、《<a href="http://www.cnblogs.com/mengdd/p/3586106.html" target="_blank" rel="external">Git 撤销修改1</a>》、《<a href="http://blog.csdn.net/baple/article/details/39640129" target="_blank" rel="external">Git 撤销修改2</a>》。</p>
<p>我们上面在示范 <code>commit -m</code> 多行 log 时，commit 的 Hash ID 是 <code>0b9420ce187b8e8b5307b49f3b6af038847e4857</code>：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  test git:(master) &#10007; git commit -m $&#39;log line 1\nlog line 2&#39;&#10;&#10;&#10140;  test git:(master) git log &#10;&#10;commit 0b9420ce187b8e8b5307b49f3b6af038847e4857</span><br></pre></td></tr></table></figure>
<p>假如，我们后来针对 <code>test</code> 这个版本库作了多次 commit 提交，怎么才能回退到多行log这个初始版本呢？<br>执行 <code>git reset --hard &lt;commit&gt;</code> 命令，可以回退到指定 commit。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">git reset [&#60;mode&#62;] [&#60;commit&#62;]&#10;           This form resets the current branch head to &#60;commit&#62; and possibly updates the index (resetting it to the tree of &#60;commit&#62;) and the working tree depending on &#60;mode&#62;. If &#60;mode&#62; is omitted, defaults to &#34;--mixed&#34;. The &#60;mode&#62; must be one of the following:&#10;&#10;&#10;&#10; --hard&#10;               Resets the index and working tree. Any changes to tracked files in the working tree since &#60;commit&#62; are discarded.</span><br></pre></td></tr></table></figure>
<p>执行  <code>git reset --hard 0b9420ce187b8e8b5307b49f3b6af038847e4857</code> ，可以回退到 0b9420ce187b8e8b5307b49f3b6af038847e4857 这个版本。</p>
<h3 id="重命名文件（夹）">重命名文件（夹）</h3><p><strong><a href="http://www.patrick-wied.at/blog/rename-files-and-folders-with-git" target="_blank" rel="external">Rename files and folders with git</a></strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mv oldfolder newfolder  &#10;git add newfolder  &#10;git remove oldfolder</span><br></pre></td></tr></table></figure>
<p>本质上就是备份重命名，然后 remove 旧的，add 新的，实现替换重命名。<br>执行完以上命令后，可以进一步执行 <code>git commit</code> 提交缓存的 <code>rename</code> 操作到本地git仓库生效。</p>
<h2 id="git_push_(_merge_local_to_remote_)">git push ( merge local to remote )</h2><p>前面我们本地 git 初始化了 resizableImageWithCapInsets 项目，并新增提交了  README.md 文件，所有改动已经提交到了本地仓库的 HEAD，但是还没到提交到 git 远程仓库。执行 <code>git status</code> 命令可查看当前状态：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  resizableImageWithCapInsets git:(master) git status  &#10;On branch master  &#10;Your branch is ahead of &#39;origin/master&#39; by 1 commit.  &#10;   (use &#34;git push&#34; to publish your local commits)  &#10;nothing to commit, working directory clean</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Your branch is ahead of &#39;origin/master&#39; by 1 commit</code>：提示我们的git本地仓库已经超过远程仓库一个版本。  </li>
<li><code>use &quot;git push&quot; to publish your local commits</code>：建议我们使用 <strong><code>git push</code></strong> 命令发布本地仓库上提交的修改。</li>
</ul>
<p>git 是分布式版本控制系统。对于一个分布式节点来说，其它节点的 git 仓库都可以作为本地仓库的<strong>远程仓库</strong>，可理解为“git 服务器”。当项目进行到一定的阶段时，要同别人分享目前的成果，可以使用 <code>git push</code> 命令将本地仓库中的数据推送到远程仓库。</p>
<p>在当前 Working tree 执行 <code>git remote -v</code> 查看其对应的远程仓库。<br>resizableImageWithCapInsets<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  resizableImageWithCapInsets git:(master) &#10007; git remote -v</span><br></pre></td></tr></table></figure></p>
<p>可以看到列出来的结果为空，实际上我们本地演示的 git 仓库尚未挂接到任何远端仓库。</p>
<p>这里移步 <a href="https://github.com/" target="_blank" rel="external">github</a>，关于本地通过 SSH 与 github 连接请参考《<a href="http://blog.csdn.net/phunxm/article/details/45083335" target="_blank" rel="external">Mac下git通过SSH进行免密码安全连接github</a>》。<br>由于<code>Github does not provide shell access</code>，因此需要去 github 个人主页手动创建仓库。Add a New Repository，命名为 resizableImageWithCapInsets，对应的URL为：</p>
<table>
<thead>
<tr>
<th>type</th>
<th>URL</th>
</tr>
</thead>
<tbody>
<tr>
<td>SSH clone URL</td>
<td>git@github.com:fan2/resizableImageWithCapInsets.git</td>
</tr>
<tr>
<td>HTTPS clone URL</td>
<td><a href="https://github.com/fan2/resizableImageWithCapInsets.git" target="_blank" rel="external">https://github.com/fan2/resizableImageWithCapInsets.git</a></td>
</tr>
<tr>
<td>Subversion checkout URL</td>
<td><a href="https://github.com/fan2/resizableImageWithCapInsets" target="_blank" rel="external">https://github.com/fan2/resizableImageWithCapInsets</a></td>
</tr>
</tbody>
</table>
<p>由上可知 github 也提供了 subversion 支持，实际上 git 也可以与通过 <a href="http://blog.chinaunix.net/uid-11639156-id-3077471.html" target="_blank" rel="external">git-svn</a> 子命令与已有的SVN中心库进行同步。</p>
<h3 id="连接远程仓库">连接远程仓库</h3><p>git 对远程仓库的操作主要是基于 <code>git remote</code> 命令：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  ~  git remote --help&#10;&#10;NAME&#10;       git-remote - Manage set of tracked repositories&#10;&#10;DESCRIPTION&#10;       Manage the set of repositories (&#34;remotes&#34;) whose branches you track.&#10;&#10;COMMANDS&#10;&#10;       add&#10;           Adds a remote named &#60;name&#62; for the repository at &#60;url&#62;.&#10;&#10;       remove, rm&#10;           Remove the remote named &#60;name&#62;. All remote-tracking branches and&#10;           configuration settings for the remote are removed.&#10;&#10;       set-url&#10;           Changes URLs for the remote.</span><br></pre></td></tr></table></figure>
<p>Adds a remote named <name> for the repository at <url>. </url></name></p>
<p>下面执行 <code>git remote add</code> 命令将当前本地 git 仓库挂接到指定的远程仓库（即追踪远程仓库）：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  resizableImageWithCapInsets git:(master) &#10007; git remote add origin git@github.com:fan2/resizableImageWithCapInsets.git</span><br></pre></td></tr></table></figure>
<p>这里将 github 远端仓库地址保存到 <code>origin</code> 变量中，后面 push、fetch、merge 等操作可直接引用 origin 变量指代远端地址。<br>此时再执行执行 <code>git remote -v</code>（–verbose：Be a little more verbose and show remote url after name），可查看 origin 具体代表的 fetch/push 远端地址：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  resizableImageWithCapInsets git:(master) &#10007; git remote -v  &#10;origin&#9;git@github.com:fan2/resizableImageWithCapInsets.git (fetch)  &#10;origin&#9;git@github.com:fan2/resizableImageWithCapInsets.git (push)</span><br></pre></td></tr></table></figure>
<p>如果执行 <code>git remote add</code> 命令时提示 <code>fatal: remote origin already exists.</code>，或者想更改挂接的远端地址（比如远程仓库重命名了或移动了），可以按照以下步骤操作：</p>
<blockquote>
<p>先执行命令：git remote rm origin<br>再执行命令：git remote add origin <remotegitrepourl></remotegitrepourl></p>
</blockquote>
<p><strong><code>git remote set-url</code></strong>（Changes URLs for the remote）相当于 rm+add：</p>
<blockquote>
<p><a href="https://help.github.com/articles/changing-a-remote-s-url/" target="_blank" rel="external">Changing a remote’s URL</a><br><a href="http://stackoverflow.com/questions/1800859/how-can-i-change-the-remote-target-repository-url-on-windows" target="_blank" rel="external">How can I change the remote/target repository URL</a><br><a href="http://stackoverflow.com/questions/2432764/change-the-uri-url-for-a-remote-git-repository" target="_blank" rel="external">Change the URI (URL) for a remote Git repository</a></p>
</blockquote>
<p>出于安全考虑，一般公司可能会屏蔽掉 SSH 协议，此时可以 <code>rm &amp; add</code> (或 set-url) 切换为 HTTPS clone URL，但是每次 git push 时都会提示输入用户名和密码。在 OS X 上可以使用 keychain 来缓存密码：</p>
<blockquote>
<p>git config –global credential.helper osxkeychain</p>
</blockquote>
<h3 id="git推送更新到远程仓库">git推送更新到远程仓库</h3><p>我们前面使用 <code>git commit</code> 命令将本地工作目录的变更提交（合并）到本地仓库，解析来可以使用 <code>git push</code> 命令来将本地仓库的变更提交（合并）到它所追踪的远程仓库：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">➜  ~  git push <span class="comment">--help</span></span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       git-push - <span class="operator"><span class="keyword">Update</span> remote refs along <span class="keyword">with</span> associated objects</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       Updates remote refs <span class="keyword">using</span> <span class="keyword">local</span> refs, <span class="keyword">while</span> sending objects necessary <span class="keyword">to</span> <span class="keyword">complete</span> the given refs.</span><br><span class="line"></span><br><span class="line">OPTIONS</span><br><span class="line">       -u, <span class="comment">--set-upstream</span></span><br><span class="line">           <span class="keyword">For</span> every branch that <span class="keyword">is</span> up <span class="keyword">to</span> <span class="built_in">date</span> <span class="keyword">or</span> successfully pushed, <span class="keyword">add</span> upstream (<span class="keyword">tracking</span>) <span class="keyword">reference</span>, used <span class="keyword">by</span> argument-<span class="keyword">less</span> git-pull(<span class="number">1</span>) <span class="keyword">and</span> other commands.</span><br><span class="line">           <span class="keyword">For</span> more information, see branch.&lt;<span class="keyword">name</span>&gt;.<span class="keyword">merge</span> <span class="keyword">in</span> git-config(<span class="number">1</span>).</span></span><br></pre></td></tr></table></figure>
<p>执行以下命令可以将本地仓库变更提交（合并）到它所追踪的远程仓库 origin 的 master 分支：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  resizableImageWithCapInsets git:(master) &#10007; git push -u origin master</span><br></pre></td></tr></table></figure>
<h2 id="git_rebase_from_remote_(_pull_=_fetch_+_merge)">git rebase from remote ( pull = fetch + merge)</h2><p>当本地仓库跟踪的远程仓库发生变更时，需要rebase（merge from remote to local）。</p>
<h3 id="fetch_+_merge">fetch + merge</h3><ul>
<li><code>git fetch</code> 取得两个版本的差异：</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  ~  git fetch --help&#10;&#10;NAME&#10;       git-fetch - Download objects and refs from another repository&#10;&#10;DESCRIPTION&#10;       Fetch branches and/or tags (collectively, &#34;refs&#34;) from one or more other&#10;       repositories.</span><br></pre></td></tr></table></figure>
<p>调用 <code>git fetch origin</code> 取得 remote 仓库 origin（master分支）相对local repository HEAD 的变动 diff delta。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  resizableImageWithCapInsets git:(master) &#10007; git fetch origin</span><br></pre></td></tr></table></figure>
<ul>
<li><code>git merge</code>命令合并两个版本：</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  ~  git merge --help&#10;&#10;NAME&#10;       git-merge - Join two or more development histories together&#10;&#10;DESCRIPTION&#10;       Incorporates changes from the named commits (since the time their histories&#10;       diverged from the current branch) into the current branch. This command is used&#10;       by git pull to incorporate changes from another repository and can be used by&#10;       hand to merge changes from one branch into another.</span><br></pre></td></tr></table></figure>
<p>调用 <code>git merge origin/master</code> 把更新（远程origin/master相对local repository的 diff ）合并（patch）到本地分支 HEAD 。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  resizableImageWithCapInsets git:(master) &#10007; git merge origin/master</span><br></pre></td></tr></table></figure>
<p>如有多个分支，可调用 <code>git branch</code> 命令查看当前分支。</p>
<h3 id="pull">pull</h3><p>当我们在本地修改了文件准备 push 推送提交时，有人已经 push 改动过远程仓库，此时 git 会提示 failed，需要执行 <strong>pull before push</strong>：</p>
<p><img src="http://img.blog.csdn.net/20150925230344452" alt="git pull &amp; push"></p>
<blockquote>
<p>git pull = fetch + merge</p>
</blockquote>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">➜  ~  git pull <span class="comment">--help</span></span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       git-pull - Fetch <span class="built_in">from</span> <span class="operator">and</span> integrate <span class="operator">with</span> another repository <span class="operator">or</span> <span class="operator">a</span> <span class="built_in">local</span> branch</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       Incorporates changes <span class="built_in">from</span> <span class="operator">a</span> remote repository <span class="keyword">into</span> <span class="operator">the</span> current branch. In its</span><br><span class="line">       default mode, git pull is shorthand <span class="keyword">for</span> git fetch followed <span class="keyword">by</span> git <span class="built_in">merge</span></span><br><span class="line">       FETCH_HEAD.</span><br><span class="line"></span><br><span class="line">       More precisely, git pull runs git fetch <span class="operator">with</span> <span class="operator">the</span> given parameters <span class="operator">and</span> calls git</span><br><span class="line">       <span class="built_in">merge</span> <span class="built_in">to</span> <span class="built_in">merge</span> <span class="operator">the</span> retrieved branch heads <span class="keyword">into</span> <span class="operator">the</span> current branch. With</span><br><span class="line">       <span class="comment">--rebase, it runs git rebase instead of git merge.</span></span><br></pre></td></tr></table></figure>
<p>一般在执行 <code>git pull</code> 之后，重新执行 <code>git push</code> 可成功提交。</p>
<p>有时候，别人和自己改动了同一个文件，当自己 pull 时会提示 conflict：</p>
<p><img src="http://img.blog.csdn.net/20150925230223046" alt="git conflict"></p>
<p><code>Automatic merge failed</code>，此时需要我们手动解决冲突再重新 push 提交（fix conflicts and then commit the result）。</p>
<h2 id="参考：">参考：</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;《<a href="http://blog.jobbole.com/50603/" target="_blank" rel="external">写给Git初学者的7个建议</a>》《<a href="http://www.devtang.com/blog/2012/02/03/talk-about-svn-and-git/" target="_blank" rel="external">Git 的使用感受</a>》<br>&nbsp;&nbsp;&nbsp;&nbsp;《<a href="http://blog.csdn.net/xiahouzuoxin/article/details/9393119" target="_blank" rel="external">我也用github</a>》《<a href="http://www.cnblogs.com/fnng/archive/2012/01/07/2315685.html" target="_blank" rel="external">git/github初级运用自如</a>》</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;《<a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="external">git - 简明指南</a>》《<a href="http://www.ibm.com/developerworks/cn/opensource/os-cn-tourofgit/" target="_blank" rel="external">IBM developerWorks-Git之旅</a>》<br>&nbsp;&nbsp;&nbsp;&nbsp;《<a href="http://roclinux.cn/?cat=72&amp;paged=5" target="_blank" rel="external">看日记学git</a>》《<a href="http://blog.csdn.net/wirelessqa/article/category/1522507" target="_blank" rel="external">码农老毕-开发工具之git</a>》《<a href="http://blog.sevenche.com/2014/02/Git-cook-book/" target="_blank" rel="external">Git Cookbook</a>》<br>&nbsp;&nbsp;&nbsp;&nbsp;《<a href="http://blog.atime.me/note/git-quick_reference.html" target="_blank" rel="external">Git快速使用指南</a>》《<a href="http://blog.atime.me/note/git-advanced_tutorial.html" target="_blank" rel="external">Git进阶教程</a>》<br>&nbsp;&nbsp;&nbsp;&nbsp;《<a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html" target="_blank" rel="external">Git远程操作详解</a>》《<a href="http://www.ruanyifeng.com/blog/2012/07/git.html" target="_blank" rel="external">Git分支管理策略</a>》</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;《<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰-Git教程</a>》《<a href="https://ihower.tw/git/index.html" target="_blank" rel="external">Git版本控制系統</a>》<br>&nbsp;&nbsp;&nbsp;&nbsp;《OPEN经验库 - <a href="http://www.open-open.com/lib/view/1328069609436" target="_blank" rel="external">Git起步</a> &amp; <a href="http://www.open-open.com/lib/view/open1328069733264.html" target="_blank" rel="external">Git基础</a>》<br>&nbsp;&nbsp;&nbsp;&nbsp;《<a href="http://wenku.baidu.com/view/51d372c22cc58bd63186bdc7.html" target="_blank" rel="external">Git权威指南</a>》《<a href="http://www.worldhello.net/gotgithub/index.html" target="_blank" rel="external">GotGitHub</a>》<br>&nbsp;&nbsp;&nbsp;&nbsp;《<a href="http://gitref.org/" target="_blank" rel="external">Git Reference</a>》《<a href="http://gitref.justjavac.com/index.html" target="_blank" rel="external">Git参考手册</a>》<br>&nbsp;&nbsp;&nbsp;&nbsp;《<a href="http://gitbook.liuhui998.com/" target="_blank" rel="external">Git Community Book 中文版</a>》《<a href="http://liuhui998.com/2011/01/21/git-adventures-1/" target="_blank" rel="external">Git历险记</a>》<br>&nbsp;&nbsp;&nbsp;&nbsp;《Git Book/Pro Git: <a href="http://git-scm.com/book/en/v2" target="_blank" rel="external">en</a> &amp; <a href="http://git-scm.com/book/zh/v2/" target="_blank" rel="external">cn</a>》《<a href="https://github.com/progit/progit2" target="_blank" rel="external">progit2 on GitHub</a>》<br>&nbsp;&nbsp;&nbsp;&nbsp;《<a href="http://www.gitguys.com/table-of-contents/?lang=zh" target="_blank" rel="external">Git Guys</a>》《<a href="https://www.atlassian.com/git/" target="_blank" rel="external">Atlassian Git Tutorial</a>》</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;《<a href="http://www.youku.com/playlist_show/id_22222576.html" target="_blank" rel="external">git中文入门教学视频1</a>》 《<a href="http://www.jikexueyuan.com/course/git/" target="_blank" rel="external">git中文入门教学视频2</a>》</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;《<a href="http://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html" target="_blank" rel="external">git-flow 备忘清单</a>》《<a href="http://www.jianshu.com/p/Ev3s2o" target="_blank" rel="external">Git工作流</a>》《<a href="http://www.ruanyifeng.com/blog/2015/08/git-use-process.html" target="_blank" rel="external">Git 使用规范流程</a>》<br>&nbsp;&nbsp;&nbsp;&nbsp;《<a href="https://ruby-china.org/topics/17590" target="_blank" rel="external">Git思维导图</a>》《<a href="http://www.cnblogs.com/1-2-3/archive/2010/07/18/git-commands.html" target="_blank" rel="external">msysGit思维导图</a>》<br>&nbsp;&nbsp;&nbsp;&nbsp;《<a href="http://blog.csdn.net/lxd875697126/article/details/22976183" target="_blank" rel="external">托管项目到GitHub</a>》《<a href="http://blog.csdn.net/yangbo_hbzjk/article/details/9022767" target="_blank" rel="external">上传本地项目到github</a>》<br>&nbsp;&nbsp;&nbsp;&nbsp;《<a href="http://www.yangzhiping.com/tech/github.html" target="_blank" rel="external">如何高效利用GitHub</a>》《<a href="http://www.cnblogs.com/cocowool/archive/2012/02/17/2356125.html" target="_blank" rel="external">Git的深入理解与GitHub托管服务的使用</a>》</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前梳理介绍过 <a href="http://blog.csdn.net/phunxm/article/details/40834427">subversion 版本控制</a>，本文承接《<a href="http://blog.csdn.net/phunxm/article/details/45083335">Mac下git通过SSH进行免密码安全连接github</a>》，结合具体操作实例贯串讲解 git 初级版本控制日常操作流程，备忘查阅。</p>]]>
    
    </summary>
    
      <category term="git-add" scheme="http://col.dog/tags/git-add/"/>
    
      <category term="git-commit" scheme="http://col.dog/tags/git-commit/"/>
    
      <category term="git-diff" scheme="http://col.dog/tags/git-diff/"/>
    
      <category term="git-init" scheme="http://col.dog/tags/git-init/"/>
    
      <category term="git-log" scheme="http://col.dog/tags/git-log/"/>
    
      <category term="git-pull" scheme="http://col.dog/tags/git-pull/"/>
    
      <category term="git-push" scheme="http://col.dog/tags/git-push/"/>
    
      <category term="git" scheme="http://col.dog/categories/git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[基于 Hexo 和 GitHub Pages 搭建博客]]></title>
    <link href="http://col.dog/2015/11/12/hello-world/"/>
    <id>http://col.dog/2015/11/12/hello-world/</id>
    <published>2015-11-12T11:27:00.000Z</published>
    <updated>2015-11-27T01:34:52.000Z</updated>
    <content type="html"><![CDATA[<p>本文详细记录了从安装 node.js / Hexo 到 使用 hexo 发布 markdown 格式的博客并托管到 GitHub 的全过程。</p>
<a id="more"></a>
<h2 id="配置环境">配置环境</h2><p>本文的操作流程和步骤基于 MacBook Pro + OS X EI Capitan 平台。</p>
<h2 id="安装_Node-js_+_NPM">安装 Node.js + NPM</h2><h3 id="什么是_Node-js_?">什么是 Node.js ?</h3><p><a href="http://nodejs.cn/" target="_blank" rel="external">Node.js</a> 是一个基于 <a href="https://developers.google.com/v8/" target="_blank" rel="external">Chrome V8</a> 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 <a href="https://www.npmjs.com/" target="_blank" rel="external">npm</a>，是全球最大的跨平台开源库生态系统。<br>正如 <a href="http://en.wikipedia.org/wiki/Nodejs" target="_blank" rel="external">维基百科</a> 所说：“Node.js 是谷歌 V8 引擎、libuv 平台抽象层以及主体使用 Javscript 编写的核心库三者集合的一个包装外壳。”   </p>
<blockquote>
<p>注：V8是谷歌开发的，目前公认最快的 Javascript 解析引擎；libuv 是一个开源的、为 Node 定制而生的跨平台异步 IO 库。</p>
</blockquote>
<p>Node.js 服务器端和网络应用程序是使用 JavaScript 脚本语言编写，并可以在 Mac OS X、Microsoft Windows 和 Linux 内的 Node.js 运行时运行。<br>Node.js还提供了丰富的各种模块的 <a href="http://nodeapi.ucdok.com/" target="_blank" rel="external">JavaScript</a> 库，从而简化了 Node.js 的使用，方便 Web 应用程序的研究与开发。</p>
<blockquote>
<p>Node.js = Runtime Environment + JavaScript Library</p>
</blockquote>
<p><a href="http://www.ibm.com/developerworks/cn/opensource/os-nodejs/" target="_blank" rel="external">Node.js 究竟是什么？</a> <a href="http://blog.jobbole.com/53736/" target="_blank" rel="external">为什么要用 Node.js ?</a><br><a href="http://www.zhihu.com/question/19653241" target="_blank" rel="external">使用 Node.js 的优势和劣势都有哪些？</a> <a href="https://github.com/nodejs/node-v0.x-archive/wiki/Projects,-Applications,-and-Companies-Using-Node" target="_blank" rel="external">谁在使用 Node.js ?</a>  </p>
<h3 id="安装/升级_Node-js">安装/升级 Node.js</h3><p>可以到 <a href="https://nodejs.org/" target="_blank" rel="external">Node.js 官网</a> 上下载最新的 node-v5.0.0.pkg for OS X (x64) 安装包到本地进行安装。<br>也可以使用 brew（The missing package manager for OS X）包管理器命令行工具进行安装。  </p>
<p>brew 全称为 <a href="http://brew.sh/index.html" target="_blank" rel="external">Homebrew</a>，是 UNIX 上的软件包管理工具。  </p>
<blockquote>
<p>Homebrew  is  the easiest and most flexible way to install the UNIX tools.</p>
</blockquote>
<p>在终端使用 <code>brew -v</code> 或 <code>brew --version</code> 命令来查看 Mac 上安装的 Homebrew 版本：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  ~  brew -v  &#10;Homebrew 0.9.5 (git revision 9cbe8; last commit 2015-11-08)</span><br></pre></td></tr></table></figure>
<p>如果没有安装 brew，可在 <a href="http://blog.csdn.net/delphiwcdj/article/details/19679891" target="_blank" rel="external">Mac 上安装 Homebrew</a> <a href="http://blog.csdn.net/aaawqqq/article/details/44088141" target="_blank" rel="external">使 OS X 更完整</a>。</p>
<h4 id="brew_install_node">brew install node</h4><p>执行 <code>brew install node</code> 命令使用 brew 安装 node：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">➜  ~  brew install <span class="keyword">node</span><span class="identifier"></span><br><span class="line"></span><span class="title">==&gt; Downloading</span> https://homebrew.bintray.com/bottles/<span class="keyword">node</span><span class="identifier"></span><span class="title">-4</span>.<span class="number">2.1</span>.el_capitan.bottle.tar.gz</span><br><span class="line"><span class="comment">######################################################################## 100.0%</span></span><br><span class="line">==&gt; Pouring <span class="keyword">node</span><span class="identifier"></span><span class="title">-4</span>.<span class="number">2.1</span>.el_capitan.bottle.tar.gz</span><br><span class="line">==&gt; Caveats</span><br><span class="line">Bash completion has been installed to:</span><br><span class="line">  /usr/local/etc/bash_completion.d</span><br><span class="line">==&gt; Summary</span><br><span class="line">🍺  /usr/local/Cellar/<span class="keyword">node</span><span class="identifier"></span><span class="title">/4</span>.<span class="number">2.1</span>: <span class="number">2738</span> files, <span class="number">36M</span></span><br></pre></td></tr></table></figure>
<p>node installed completion 之后，执行 <code>node -v</code> 命令可查看安装的 node.js 版本：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  ~  node -v&#10;v4.2.1</span><br></pre></td></tr></table></figure>
<h4 id="brew_upgrade_node">brew upgrade node</h4><p>暂时可略过此节。<br>后续可执行 <code>brew upgrade node</code> 命令可升级到最新的 node 5.1.0 ：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">faner@MBP-FAN:~|⇒  brew upgrade <span class="keyword">node</span><span class="identifier"></span><br><span class="line"></span><span class="title">==&gt; Upgrading</span> <span class="number">1</span> outdated package, with result:</span><br><span class="line"><span class="keyword">node</span><span class="identifier"> </span><span class="title">5</span>.<span class="number">1.0</span></span><br><span class="line">==&gt; Upgrading <span class="keyword">node</span><span class="identifier"></span><br><span class="line"></span><span class="title">==&gt; Downloading</span> https://homebrew.bintray.com/bottles/<span class="keyword">node</span><span class="identifier"></span><span class="title">-5</span>.<span class="number">1.0</span>.el_capitan.bottle.tar.gz</span><br><span class="line">faner@MBP-FAN:~|⇒  <span class="keyword">node</span><span class="identifier"> </span><span class="title">-v</span></span><br><span class="line">v5.<span class="number">1.0</span></span><br><span class="line">faner@MBP-FAN:~|⇒  npm -v</span><br><span class="line"><span class="number">3.3</span>.<span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>升级后，执行 <code>hexo generate</code> 报错：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#8658;  hexo g&#10;[Error: Module version mismatch. Expected 47, got 46.]&#10;&#123; [Error: Cannot find module &#39;./build/default/DTraceProviderBindings&#39;] code: &#39;MODULE_NOT_FOUND&#39; &#125;&#10;&#123; [Error: Cannot find module &#39;./build/Debug/DTraceProviderBindings&#39;] code: &#39;MODULE_NOT_FOUND&#39; &#125;</span><br></pre></td></tr></table></figure>
<p><strong><a href="http://www.jianshu.com/p/98e993305653" target="_blank" rel="external">解决方案</a></strong>：</p>
<p>由于天朝网络问题，没全部下载完（Expected 47, got 46）。具体来说，缺少 <code>dtrace-provider</code> 这个 module（可检查 node_modules 目录）。翻墙或按以下方案解决：</p>
<ol>
<li>执行 <code>npm uninstall hexo</code> 卸载 hexo；</li>
<li>执行 <code>npm install -g hexo --no-optional</code> 重新安装最简 hexo (hexo-cli: 0.1.9)；</li>
<li>cd 到博客目录，<del>删除 db.json</del>，执行 <code>npm install</code>  ，重新安装 <code>package.json</code> 中配置的依赖库(node_modules)；</li>
<li>依次执行 <code>hexo clean</code> 和 <code>hexo generate</code> ，重新编译整个博客网站。</li>
</ol>
<h2 id="NPM_安装_hexo">NPM 安装 hexo</h2><h3 id="npm_-v">npm -v</h3><p>Node.js 默认内置了模块管理工具 —— NPM（Node Package Manager），其灵感来源于 <a href="http://www.cnblogs.com/ihojin/p/ruby-gem-update-the-latest-version.html" target="_blank" rel="external">RubyGems</a>（具有版本和依赖管理功能，可以通过在线资料库便捷安装可重用的组件的管理工具）。<br>NPM 生态系统向所有人开放，任何人都可以发布自己的模块，所有的模块都可以在 NPM 资料库中找到。一个完整的公用模块列表可以在 <a href="https:://npmjs.org/" target="_blank" rel="external">NPM 的网站</a> 上找到，也可以通过与 Node.js 一同安装的 NPM 客户端命令行工具访问。<br>可执行 <code>npm -v</code> 命令查看 <code>node.js</code> 集成的 npm 包管理工具的版本：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  ~  npm -v&#10;2.14.7</span><br></pre></td></tr></table></figure>
<p>执行 <code>npm help</code> 命令可查看帮助：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  ~  npm help&#10;&#10;Usage: npm &#60;command&#62;&#10;&#10;where &#60;command&#62; is one of:&#10;&#10;&#10;&#10;npm &#60;cmd&#62; -h     quick help on &#60;cmd&#62;&#10;npm -l           display full usage info&#10;npm faq          commonly asked questions&#10;npm help &#60;term&#62;  search for help on &#60;term&#62;&#10;npm help npm     involved overview&#10;&#10;Specify configs in the ini-formatted file:&#10;    /Users/faner/.npmrc&#10;or on the command line via: npm &#60;command&#62; --key value&#10;Config info can be viewed via: npm help config&#10;&#10;npm@2.14.7 /usr/local/lib/node_modules/npm</span><br></pre></td></tr></table></figure>
<p>执行 <code>npm -l</code> 命令可查看帮助详情。</p>
<p>下文将通过 <code>npm install &lt;pkg&gt;</code> 命令来安装快速、简洁且高效的<a href="http://code.csdn.net/news/2819909" target="_blank" rel="external">静态博客框架</a> —— <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>，并基于 GitPages 托管来搭建免费开源博客。</p>
<h3 id="npm_install_hexo">npm install hexo</h3><p>执行 <code>npm install -g hexo</code> 命令安装 hexo：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  ~  npm install -g hexo&#10;&#10;&#62; fsevents@0.3.8 install /usr/local/lib/node_modules/hexo/node_modules/nunjucks/node_modules/chokidar/node_modules/fsevents&#10;&#62; node-gyp rebuild&#10;&#10;&#62; dtrace-provider@0.6.0 install /usr/local/lib/node_modules/hexo/node_modules/bunyan/node_modules/dtrace-provider&#10;&#62; node scripts/install.js&#10;&#10;&#10;&#62; fsevents@1.0.5 install /usr/local/lib/node_modules/hexo/node_modules/hexo-fs/node_modules/chokidar/node_modules/fsevents&#10;&#62; node-pre-gyp install --fallback-to-build&#10;&#10;[fsevents] Success: &#34;/usr/local/lib/node_modules/hexo/node_modules/hexo-fs/node_modules/chokidar/node_modules/fsevents/lib/binding/Release/node-v46-darwin-x64/fse.node&#34; is installed via remote&#10;/usr/local/bin/hexo -&#62; /usr/local/lib/node_modules/hexo/bin/hexo&#10;hexo@3.1.1 /usr/local/lib/node_modules/hexo</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<blockquote>
<p>npm默认为当前项目安装，<code>-g</code> 表示全局安装。</p>
</blockquote>
<h3 id="hexo_version">hexo version</h3><p>可执行 <code>hexo -v</code> 或  <code>hexo -version</code> 命令来检验安装的 hexo 版本：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  ~  hexo -v&#10;hexo-cli: 0.1.8&#10;os: Darwin 15.0.0 darwin x64&#10;http_parser: 2.5.0&#10;node: 4.2.1&#10;v8: 4.5.103.35&#10;uv: 1.7.5&#10;zlib: 1.2.8&#10;ares: 1.10.1-DEV&#10;icu: 56.1&#10;modules: 46&#10;openssl: 1.0.2d</span><br></pre></td></tr></table></figure>
<h3 id="hexo_help">hexo help</h3><p>可执行 <code>hexo --help</code> 查看帮助：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  ~  hexo --help&#10;Usage: hexo &#60;command&#62;&#10;&#10;Commands:&#10;  help     Get help on Hexo.&#10;  init     Create a new Hexo folder.&#10;  version  Display version information.&#10;&#10;Global Options:&#10;  --config  Specify config file instead of using _config.yml&#10;  --cwd     Specify the CWD&#10;  --debug   Display all verbose messages in the terminal&#10;  --safe    Disable all plugins and scripts&#10;  --silent  Hide output on console&#10;&#10;For more help, you can use &#39;hexo help [command]&#39; for the detailed information&#10;or you can check the docs: http://hexo.io/docs/</span><br></pre></td></tr></table></figure>
<p><strong>常用的 hexo 命令：</strong></p>
<ul>
<li>hexo init <code>&lt;blog&gt;</code> ：初始化 hexo 博客模板。</li>
<li>hexo n == hexo new：新建文章或页面。</li>
<li>hexo g == hexo generate：编译生成网站。</li>
<li>hexo d == hexo deploy：发布网站。</li>
<li>hexo s == hexo server：启动服务器。</li>
<li>hexo clean：清理 cache。</li>
</ul>
<p><strong>hexo 在线帮助文档：</strong></p>
<ul>
<li><a href="http://hexo.io/docs/" target="_blank" rel="external">http://hexo.io/docs/</a></li>
</ul>
<h2 id="hexo_init">hexo init</h2><p>假设我们接下来将在本地工程目录 <code>Projects/git/blog</code> 下构建博客站点（WebSite）。<br>cd 进入 <code>Projects/git/blog</code> 目录，针对该目录执行 <code>hexo init</code> 命令。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  ~  cd Projects/git&#10;&#10140;  git  mkdir blog&#10;&#10140;  git  cd blog&#10;&#10140;  blog  hexo init&#10;INFO  Copying data to ~/Projects/git/blog&#10;INFO  You are almost done! Don&#39;t forget to run &#39;npm install&#39; before you start blogging with Hexo!</span><br></pre></td></tr></table></figure>
<h3 id="博客模板">博客模板</h3><p><code>hexo init</code> 初始化成功后，可调用 <code>ls</code> 或 <a href="http://www.aikaiyuan.com/5413.html" target="_blank" rel="external"><code>tree</code></a> 命令查看 hexo 在 blog 目录下生成的模板文件：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  blog  ls&#10;_config.yml  package.json scaffolds    source       themes&#10;&#10140;  blog  tree -L 2&#10;.&#10;&#9500;&#9472;&#9472; _config.yml&#10;&#9500;&#9472;&#9472; package.json&#10;&#9500;&#9472;&#9472; scaffolds&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; draft.md&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; page.md&#10;&#9474;&#160;&#160; &#9492;&#9472;&#9472; post.md&#10;&#9500;&#9472;&#9472; source&#10;&#9474;&#160;&#160; &#9492;&#9472;&#9472; _posts&#10;&#9492;&#9472;&#9472; themes&#10;    &#9492;&#9472;&#9472; landscape&#10;&#10;5 directories, 5 files</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>文件/目录</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>_config.yml</td>
<td>网站的配置信息</td>
</tr>
<tr>
<td>package.json</td>
<td>应用程序的信息，包括依赖包(dependencies)</td>
</tr>
<tr>
<td>scaffolds</td>
<td>模板文件夹，Hexo 会根据 scaffold 来新建文件。</td>
</tr>
<tr>
<td>source</td>
<td>资源文件夹，<code>_post</code> 目录存放博客源码（markdown文件）</td>
</tr>
<tr>
<td>themes</td>
<td>主题文件夹，默认主题为landscape</td>
</tr>
</tbody>
</table>
<p><code>source</code> 下除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 / 文件夹和隐藏的文件 将会被忽略。<code>/source/_posts</code> 目录下默认有一个欢迎页 —— <code>hello-world.md</code> 文件。<br>在下文使用 <code>hexo generate</code> 生成网站时，Hexo 会编译 Markdown 和 HTML 源文件，根据主题来生成静态页面。静态页面文件将会被存放到 <code>public</code> 文件夹，而其他文件会被拷贝过去视作资源。</p>
<h3 id="npm_install">npm install</h3><p>此时，尝试执行 <code>hexo generate</code> 生成包含 Hello World 首页的博客，将提示需要执行<br><code>npm install hexo --save</code> :</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  blog  hexo generate&#10;ERROR Local hexo not found in ~/Projects/git/blog&#10;ERROR Try running: &#39;npm install hexo --save&#39;</span><br></pre></td></tr></table></figure>
<p>实际上，我们已经执行过 <code>npm install hexo</code> 。根据上一步 <code>hexo init</code> 的提示，在正式 blogging with Hexo 之前，需要执行 <code>npm install</code> 命令安装 <code>package.json</code> 里的依赖包（Dependencies）：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">➜  blog  hexo <span class="keyword">generate</span></span><br><span class="line"><span class="keyword">ERROR</span> <span class="keyword">Local</span> hexo not found <span class="keyword">in</span> ~/Projects/git/blog</span><br><span class="line"><span class="keyword">ERROR</span> Try running: 'npm install hexo --<span class="keyword">save</span>'</span><br><span class="line"></span><br><span class="line">➜  blog  npm install</span><br><span class="line"></span><br><span class="line">➜  blog  <span class="keyword">ls</span></span><br><span class="line">_config.yml  node_modules package.json scaffolds    source       themes</span><br></pre></td></tr></table></figure>
<p><code>ls</code> 可以查看到目录下将多出 <code>node_modules</code> 文件夹，其中存放 <code>npm install</code> 安装的依赖包。</p>
<h2 id="hexo_generate">hexo generate</h2><p>上面，我们在执行 <code>hexo init</code> 后，再执行 <code>npm install</code> 安装了 package.json 所依赖的包。此时，执行 <code>hexo generate</code> 命令将编译（只有欢迎页：<code>hello-world.md</code>）生成待发布的博客文件。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  blog  hexo generate&#10;INFO  Files loaded in 290 ms&#10;INFO  Generated: js/script.js&#10;INFO  Generated: fancybox/jquery.fancybox.pack.js&#10;INFO  Generated: fancybox/jquery.fancybox.js&#10;INFO  Generated: fancybox/jquery.fancybox.css&#10;INFO  Generated: fancybox/helpers/jquery.fancybox-thumbs.js&#10;INFO  Generated: fancybox/helpers/jquery.fancybox-thumbs.css&#10;INFO  Generated: fancybox/helpers/jquery.fancybox-media.js&#10;INFO  Generated: fancybox/helpers/jquery.fancybox-buttons.js&#10;INFO  Generated: fancybox/helpers/jquery.fancybox-buttons.css&#10;INFO  Generated: fancybox/helpers/fancybox_buttons.png&#10;INFO  Generated: fancybox/fancybox_sprite@2x.png&#10;INFO  Generated: fancybox/fancybox_sprite.png&#10;INFO  Generated: fancybox/fancybox_overlay.png&#10;INFO  Generated: fancybox/fancybox_loading@2x.gif&#10;INFO  Generated: fancybox/fancybox_loading.gif&#10;INFO  Generated: fancybox/blank.gif&#10;INFO  Generated: css/style.css&#10;INFO  Generated: css/images/banner.jpg&#10;INFO  Generated: css/fonts/fontawesome-webfont.woff&#10;INFO  Generated: css/fonts/fontawesome-webfont.ttf&#10;INFO  Generated: css/fonts/fontawesome-webfont.svg&#10;INFO  Generated: css/fonts/fontawesome-webfont.eot&#10;INFO  Generated: css/fonts/FontAwesome.otf&#10;INFO  Generated: 2015/11/08/hello-world/index.html&#10;INFO  Generated: archives/index.html&#10;INFO  Generated: archives/2015/index.html&#10;INFO  Generated: archives/2015/11/index.html&#10;INFO  Generated: index.html&#10;INFO  28 files generated in 794 ms&#10;&#10140;  blog  ls&#10;_config.yml  node_modules public       source&#10;db.json      package.json scaffolds    themes</span><br></pre></td></tr></table></figure>
<p><code>ls</code> 查看目录下将生成 <code>public</code> 和 <code>db.json</code> 这两个文件夹。</p>
<ol>
<li><code>db.json</code> —— json格式的静态常量数据库。  </li>
<li><code>public</code> 文件夹存放编译后的静态网站（html+css+js），也就是最后要发布的博客。  </li>
</ol>
<h3 id="public">public</h3><p>在 public 目录下执行 <code>tree -L 2</code>，可以查看其目录结构：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  blog  cd public &#10;&#10140;  public  tree -L 2&#10;.&#10;&#9500;&#9472;&#9472; 2015&#10;&#9474;&#160;&#160; &#9492;&#9472;&#9472; 11&#10;&#9500;&#9472;&#9472; archives&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; 2015&#10;&#9474;&#160;&#160; &#9492;&#9472;&#9472; index.html&#10;&#9500;&#9472;&#9472; css&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; fonts&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; images&#10;&#9474;&#160;&#160; &#9492;&#9472;&#9472; style.css&#10;&#9500;&#9472;&#9472; fancybox&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; blank.gif&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; fancybox_loading.gif&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; fancybox_loading@2x.gif&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; fancybox_overlay.png&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; fancybox_sprite.png&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; fancybox_sprite@2x.png&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; helpers&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; jquery.fancybox.css&#10;&#9474;&#160;&#160; &#9500;&#9472;&#9472; jquery.fancybox.js&#10;&#9474;&#160;&#160; &#9492;&#9472;&#9472; jquery.fancybox.pack.js&#10;&#9500;&#9472;&#9472; index.html&#10;&#9492;&#9472;&#9472; js&#10;    &#9492;&#9472;&#9472; script.js</span><br></pre></td></tr></table></figure>
<ul>
<li><code>index.html</code> 为网站首页。</li>
<li><code>js/</code> ：存放 hexo 的功能 js。</li>
<li><code>css/</code> ：存放 css 样式文件。</li>
<li><code>archives/</code> ：存放博客归档。</li>
<li>[<code>fancybox</code>][] 是一款优秀的 <a href="http://www.cnblogs.com/zhmt/archive/2011/10/06/2200152.html" target="_blank" rel="external">jquery 插件</a>，它能够展示<a href="http://www.helloweba.com/view-blog-65.html" target="_blank" rel="external">丰富的弹出层效果</a>。</li>
</ul>
<h2 id="hexo_server">hexo server</h2><p>上面通过 <code>init</code> 和 <code>generate</code> 之后，已经生成博客网站了。此时，只包含一个默认首页 hello-world.md。  </p>
<p>执行 <code>hexo server</code> 可启动 <strong>hexo server</strong> 进行本地调试：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  blog  hexo server&#10;INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.&#10;^CINFO  Bye!&#10;&#10140;  blog</span><br></pre></td></tr></table></figure>
<p>在浏览器中输入 <code>http://localhost:4000</code> 即可访问只含欢迎页和默认主题的 hexo 博客了。<br><img src="http://7xo5uz.com1.z0.glb.clouddn.com/hexo-hello.png" alt="hexo-hello_world"></p>
<p>按下 <code>Ctrl+C</code> 退出 hexo 服务器。</p>
<h2 id="hexo_deploy">hexo deploy</h2><h3 id="配置_Deployment">配置 Deployment</h3><p>编辑站点配置文件(<code>/_config.yml</code>)里面的 Deployment 发布配置。<br>其中 deploy type 修改为 <code>github</code>；repository 修改为自己在 Github 上的 User Pages 的地址：<code>https://github.com/fan2/fan2.github.io.git</code> 。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># Deployment&#10;## Docs: http://hexo.io/docs/deployment.html&#10;deploy:&#10;  type: github&#10;  repository: git@github.com:fan2/fan2.github.io.git&#10;  branch: master</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ol>
<li>Repository：url 必须是 SSH 形式的，不支持 HTTPS 形式，否则会出现错误：<code>is not a valid repositor URL!</code>。  </li>
<li><p>使用 SSH url，如果电脑没有开放 SSH 端口，会致部署失败：</p>
<blockquote>
<p>fatal: Could not read from remote repository.<br>Please make sure you have the correct access rights and the repository exists.</p>
</blockquote>
</li>
<li><p>如果是为一个项目制作介绍网站，那么需要把 branch 设置为 gh-pages 。</p>
</li>
</ol>
<h3 id="hexo_deploy-1">hexo deploy</h3><p>执行 <code>hexo deploy</code> ，将静态网站代码（public/*）上传到 github 上。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  blog hexo deploy&#10;ERROR Deployer not found: github</span><br></pre></td></tr></table></figure>
<p>原因是在 hexo 3.0 之后, 不仅 github 的 deploy 的 type 从 github 改为了 git，其中的 deploy 功能也被单独做成一个模块，需要另外安装。所以我们需要安装 <strong>hexo-deployer-git</strong>。</p>
<p><strong>解决方案：</strong></p>
<ol>
<li><a href="http://www.v2ex.com/t/175940" target="_blank" rel="external">将 github 修改为 git</a>， 还是报错；</li>
<li><a href="http://blog.163.com/gis_warrior/blog/static/19361717320153100184696/" target="_blank" rel="external">安装 hexo-deployer-git</a>:</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  blog npm install hexo-deployer-git --save&#10; &#10;&#62; fsevents@1.0.5 install /Users/faner/Projects/git/blog/node_modules/hexo-deployer-git/node_modules/hexo-fs/node_modules/chokidar/node_modules/fsevents&#10;&#62; node-pre-gyp install --fallback-to-build&#10;&#10;[fsevents] Success: &#34;/Users/faner/Projects/git/blog/node_modules/hexo-deployer-git/node_modules/hexo-fs/node_modules/chokidar/node_modules/fsevents/lib/binding/Release/node-v46-darwin-x64/fse.node&#34; is installed via remote</span><br></pre></td></tr></table></figure>
<p>其中 <code>--save</code> 参数用于把模块的版本号添加到 package.json 文件中的依赖里（dependencies），否则在安装完之后需要手动添加。<br>下载安装完成后，<code>node_modules</code> 下将新增目录 <code>hexo-deployer-git</code>。</p>
<p>此时，重新执行 <code>hexo deploy</code> ，提交发布成功！</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  blog hexo deploy                         &#10;INFO  Deploying: git&#10;INFO  Setting up Git deployment...&#10;Initialized empty Git repository in /Users/faner/Projects/git/blog/.deploy_git/.git/&#10;[master (root-commit) 578b537] First commit&#10; 1 file changed, 0 insertions(+), 0 deletions(-)&#10; create mode 100644 placeholder&#10;INFO  Clearing .deploy folder...&#10;INFO  Copying files from public folder...&#10;&#10;&#10;&#10;To git@github.com:fan2/fan2.github.io.git&#10; + 9a3d901...6fe0445 master -&#62; master (forced update)&#10;Branch master set up to track remote branch master from git@github.com:fan2/fan2.github.io.git.&#10;INFO  Deploy done: git</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ol>
<li>部署会覆盖掉你之前在版本库 <code>fan2.github.io</code> 中存放的文件。  </li>
<li><code>hexo deploy</code> 时将在博客根目录下生成 <code>.deploy_git</code> 文件夹，下一次 <code>hexo deploy</code> 将会基于 diff 提交差异量。</li>
</ol>
<h2 id="写新文章，更新博客">写新文章，更新博客</h2><p>新建博文，其中 postName 是博文题目：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">hexo new &#34;postName&#34;</span><br></pre></td></tr></table></figure>
<p>hexo 会自动在博客目录 <code>source/_posts</code> 下生成 postName.md 文件。</p>
<h3 id="front-matter">front-matter</h3><p>markdown 文件开头的 <strong>front-matter</strong> 属性（ <code>---</code> 上面的区域）中可以定义文章的属性，便于 hexo 主题模板生成格式化的文章。</p>
<p>以下是本文的 front-matter，其中定义了标题、日期、所属分类和多标签：</p>
<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">title: 基于 Hexo 和 GitHub Pages 搭建博客</span><br><span class="line">date: 2015-11-12 19:27:00</span><br><span class="line">categories: Hexo</span><br><span class="line">tags:</span><br><span class="line">-<span class="ruby"> node.js</span><br><span class="line"></span>-<span class="ruby"> npm</span><br><span class="line"></span>-<span class="ruby"> hexo</span><br><span class="line"></span>-<span class="ruby"> <span class="keyword">next</span></span><br><span class="line"></span>-<span class="ruby"> feed</span><br><span class="line"></span>-<span class="ruby"> analytics</span><br><span class="line"></span>-<span class="ruby"> sitemap</span></span><br></pre></td></tr></table></figure>
<p>以下是下一篇博文《git 版本控制》的 front-matter，其中定义了标题、日期、所属分类和多标签：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">title: git 版本控制</span><br><span class="line">date: 2015-11-17 07:13:23</span><br><span class="line">categories: git</span><br><span class="line"><span class="header">tags: [git-init, git-add, git-commit, git-pull, git-push]</span><br><span class="line">---</span></span><br></pre></td></tr></table></figure>
<h3 id="重新生成部署">重新生成部署</h3><p>每次修改更新本地博客源码文件后，需要针对该博客目录执行 <code>hexo generate</code> 重新（增量）编译；再键入 <code>hexo deploy</code> 即可上传到 Github 上。这两步也可合并为 <code>hexo d -g</code> ，先生成再部署。<br>如果 SSH 被禁用了，建议手动将 <code>public/</code> 目录下的静态网站 git push 到 GitHub Pages 博客仓库上。</p>
<h2 id="图片存储">图片存储</h2><p>在 <code>source</code> 下建立与博客 <code>blog.md</code> 同名的目录 <code>blog</code> ，用于存放图片等资源文件，首页相对引用成功；但点击进入文章，相对引用失败！<br>可参照 <a href="https://hexo.io/zh-cn/docs/asset-folders.html" target="_blank" rel="external">hexo 资源文件夹</a> ，看看如何设置 asset 相对路径。也可采用<a href="http://www.qiniu.com/" target="_blank" rel="external">七牛</a>等云存储平台做图床，使用绝对路径。</p>
<h2 id="404_——_找不到页面">404 —— 找不到页面</h2><p>当我们访问一个不存在（已删除、重命名）的页面时，将报告 HTTP 404 错误 (Not Found error message) ，提示找不到页面。<br>如果你已经绑定顶级域名，可以自定义 404 页面（GitHub 默认分配的二级域名是不起作用的），推荐使用 <a href="http://www.qq.com/404/" target="_blank" rel="external">腾讯公益404</a>。</p>
<p>新建 source/404.html，在 <code>&lt;body&gt;</code> 部分嵌入腾讯公益404的 js 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">layout: default</span><br><span class="line">---</span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"UTF-8"</span> /&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="title">title</span>&gt;</span>404<span class="tag">&lt;/<span class="title">title</span>&gt;</span>                                                                                                                                        </span><br><span class="line">    <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span> <span class="attribute">src</span>=<span class="value">"http://www.qq.com/404/search_children.js"</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span> <span class="attribute">homePageUrl</span>=<span class="value">"http://col.dog/"</span> <span class="attribute">homePageName</span>=<span class="value">"返回 col.dog 主页"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>修改“homePageUrl”、“homePageName”这两个参数即可定制返回链接。<br>重新生成部署，在访问本站不存在的页面（资源）或目录时，将显示 <a href="http://col.dog/unknown">腾讯公益 404 页面</a>。</p>
<h2 id="配置主题——Next">配置主题——<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">Next</a></h2><p>在终端 cd 到博客站点目录 <code>Projects/git/blog/theme</code> 下，git clone 下载 NEXT 主题到本地目录 <code>themes/next</code> 下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  blog  git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<p>编辑站点配置文件，将字体从繁体切换为简体、将主题从默认的 landscape 切换为 next：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># Site&#10;language: zh-Hans #zh-hk&#10;&#10;# Extensions&#10;## Themes: http://hexo.io/themes/&#10;theme: next # landscape</span><br></pre></td></tr></table></figure>
<p>重新生成部署网站，将按 next 主题风格排版布局站点。</p>
<h3 id="开启_Mist">开启 Mist</h3><p>编辑主题配置文件(<code>/themes/next/_config.yml</code>) ，开启 NexT.Mist 风格主题：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># Schemes&#10;scheme: Mist</span><br></pre></td></tr></table></figure>
<h3 id="配置菜单">配置菜单</h3><p>编辑主题配置文件里面的 menu 项，配置顶部菜单：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">menu:&#10;  home: /&#10;  archives: /archives&#10;  categories: /categories&#10;  tags: /tags&#10;  # commonweal: /404.html&#10;  about: /about</span><br></pre></td></tr></table></figure>
<ol>
<li>home: /，<strong>首页</strong>，点击将显示根目录 /index.html 。</li>
<li>archives: /archives，<strong>归档</strong>，点击将显示文章列表。</li>
<li>categories: /categories，<strong>分类</strong>，点击将显示文章分类。</li>
<li>tags: /tags，<strong>标签</strong>，点击将显示文章标签。</li>
<li>about: /about，<strong>关于</strong>，介绍一下自己。</li>
</ol>
<h3 id="创建分类页面"><a href="https://github.com/iissnan/hexo-theme-next/wiki/%E5%88%9B%E5%BB%BA%E6%A0%87%E7%AD%BE%E4%BA%91%E9%A1%B5%E9%9D%A2" target="_blank" rel="external">创建分类页面</a></h3><p>默认点击访问 分类(Categories) 链接，将会提示 404，找不到页面。</p>
<ol>
<li>新建一个页面，命名为 categories 。命令如下：</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>
<ol>
<li>编辑刚才新建的页面(<code>/source/categories/index.md</code>)，将页面的类型（type）设置为 categories ，主题框架模板将自动在这个页面显示所有分类。</li>
</ol>
<p>在该 markdown 文件中，只需要定义文章开头的 <strong>front-matter</strong> 属性（文件最上方以 <code>---</code> 分隔的区域），正文为空:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">title: 分类</span><br><span class="line">type: "categories"</span><br><span class="line"><span class="header">comments: false</span><br><span class="line">---</span></span><br></pre></td></tr></table></figure>
<p>重新生成部署生效。</p>
<p><strong>注意：</strong></p>
<blockquote>
<p>下文有启用 多说 或者 Disqus 评论，模板生成的分类页面也会带有评论。这里添加字段 comments ，并将值设置为 false ，关闭分类页面的评论。</p>
</blockquote>
<h3 id="创建标签页面"><a href="https://github.com/iissnan/hexo-theme-next/wiki/%E5%88%9B%E5%BB%BA%E5%88%86%E7%B1%BB%E9%A1%B5%E9%9D%A2" target="_blank" rel="external">创建标签页面</a></h3><p>默认点击访问 分类(Tags) 链接，将会提示 404，找不到页面。</p>
<ol>
<li>新建一个页面，命名为 tags 。命令如下：</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>
<ol>
<li>编辑刚才新建的页面(<code>/source/tags/index.md</code>)，将页面的类型（type）设置为 tags ，主题框架模板将自动在这个页面显示所有分类。</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">title: 标签</span><br><span class="line">type: "tags"</span><br><span class="line"><span class="header">comments: false</span><br><span class="line">---</span></span><br></pre></td></tr></table></figure>
<ul>
<li>标签页面也关闭了评论，重新生成部署生效。</li>
<li>多标签的两种书写格式参照 <strong>front-matter</strong> 章节。</li>
</ul>
<h3 id="创建“关于我”页面"><a href="https://github.com/iissnan/hexo-theme-next/wiki/%E5%88%9B%E5%BB%BA-%22%E5%85%B3%E4%BA%8E%E6%88%91%22-%E9%A1%B5%E9%9D%A2" target="_blank" rel="external">创建“关于我”页面</a></h3><p>Hexo默认不生成 About 页面，有需要的话可以创建一个叫 about 的 page，然后再添加到菜单项。</p>
<p>在命令行里面输入：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">hexo new page &#34;about&#34;</span><br></pre></td></tr></table></figure>
<p>然后，你会发现 source 里面多了个 about 目录，里面有个 index.md。其实你也可以手动建立 markdown 文件，页面的格式和文章一样。</p>
<h2 id="添加多说评论"><a href="https://github.com/iissnan/hexo-theme-next/wiki/%E8%AE%BE%E7%BD%AE%E5%A4%9A%E8%AF%B4-DISQUS" target="_blank" rel="external">添加多说评论</a></h2><p>使用社交账号登录 <a href="http://dev.duoshuo.com/threads/541d3b2b40b5abcd2e4df0e9" target="_blank" rel="external">多说</a> 网站，创建一个站点。具体步骤如下：</p>
<ol>
<li>登录后在首页选择 “我要安装”。</li>
<li>创建站点，填写站点相关信息。注意，<strong>多说域名</strong> 这一栏填写的即是你的 duoshuo_shortname。</li>
<li>编辑主题配置文件，添加 duoshuo_shortname 字段，设置如下：</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">duoshuo_shortname: your-duoshuo-shortname</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<blockquote>
<p>duoshuo short name: 你的多说二级域名为去掉 <code>.duoshuo.com</code> 的前缀部分。</p>
</blockquote>
<h2 id="添加_RSS/Feed"><a href="https://github.com/xiangming/landscape-plus/issues/31" target="_blank" rel="external">添加 RSS/Feed</a></h2><p>很多新闻网站和 CMS 都会生成 atom 格式的 xml 文件（atom.xml），以供 RSS 订阅软件或聚合网站读取。这个在前几年是一种主流的新闻分享方式，聚合网站通过远程读取 atom 文件的内容，将内容通过指定的格式输出在网站上，以供大家浏览。</p>
<p>1.在命令行终端中，通过 npm 来安装 <a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="external">hexo-generator-feed</a> 插件：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  github-pages git:(master) &#10007; npm install hexo-generator-feed --save&#10;hexo-generator-feed@1.0.3 node_modules/hexo-generator-feed&#10;&#9500;&#9472;&#9472; object-assign@3.0.0&#10;&#9492;&#9472;&#9472; ejs@1.0.0</span><br></pre></td></tr></table></figure>
<p>2.在站点配置文件中加载 hexo-generator-feed 插件：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Plugins:&#10;- hexo-generator-feed</span><br></pre></td></tr></table></figure>
<p>3.在站点配置文件中配置 <a href="http://www.w4s.cn/feed/atom" target="_blank" rel="external">Atom XML 聚合</a> 格式的 feed：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#Feed Atom&#10;feed:&#10;  type: atom&#10;  path: atom.xml&#10;  limit: 20</span><br></pre></td></tr></table></figure>
<p>主题配置文件中的 <code>rss</code> 字段的值保持为空，以便<a href="https://github.com/iissnan/hexo-theme-next/wiki/%E6%98%BE%E7%A4%BA-feed-%E9%93%BE%E6%8E%A5" target="_blank" rel="external">显示 feed 链接</a>。<br>重新编译网站，将在 <code>public</code> 目录下生成 <code>atom.xml</code> 文件。用户点击博客右侧边栏中的 <code>RSS</code> 图标，即可访问 <a href="http://col.dog/atom.xml">http://col.dog/atom.xml</a> 。</p>
<p>在 Mac 下使用 <code>brew cask install vienna</code> 命令安装 <a href="http://www.vienna-rss.org" target="_blank" rel="external">ViennaRSS</a>：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">faner@MBP-FAN:~|&#8658;  brew cask search vienna&#10;==&#62; Exact match&#10;vienna&#10;faner@MBP-FAN:~|&#8658;  brew cask info vienna  &#10;vienna: 3.0.9&#10;Vienna&#10;http://www.vienna-rss.org&#10;Not installed&#10;https://github.com/phinze/homebrew-cask/blob/master/Casks/vienna.rb&#10;==&#62; Contents&#10;  Vienna.app (app)&#10;&#8658;  brew cask audit vienna  &#10;audit for vienna: passed&#10;faner@MBP-FAN:~|&#8658;  brew cask install vienna&#10;==&#62; Downloading https://dl.bintray.com/viennarss/vienna-rss/Vienna3.0.9.tgz&#10;######################################################################## 100.0%&#10;==&#62; Symlinking App &#39;Vienna.app&#39; to &#39;/Users/faner/Applications/Vienna.app&#39;&#10;&#127866;  vienna staged at &#39;/opt/homebrew-cask/Caskroom/vienna/3.0.9&#39; (1180 files, 22M)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>新增订阅</strong>（Create a new subscription）：</li>
</ul>
<blockquote>
<p>Source：<strong>URL</strong><br>URL of news feed：<a href="http://col.dog/atom.xml">http://col.dog/atom.xml</a></p>
</blockquote>
<p><img src="http://7xo5uz.com1.z0.glb.clouddn.com/Vienna-Elsewhere.png" alt="Vienna-Elsewhere"></p>
<ul>
<li><strong>偏好设置</strong><ol>
<li><code>View | Style</code><ul>
<li>default: Tyger Graphite</li>
<li>可选：Tyger、Minimalista Sans-serif</li>
</ul>
</li>
<li><code>Folder|</code> 展开格式<ul>
<li>Use Current Style for Articles：展开摘要</li>
<li>Use Web Pages for Articles：展开全文</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="添加统计分析（Analytics）">添加统计分析（Analytics）</h2><h3 id="hexo/next_添加_Google/百度_统计"><a href="https://github.com/iissnan/hexo-theme-next/wiki/%E6%B7%BB%E5%8A%A0-Google---%E7%99%BE%E5%BA%A6-%E7%BB%9F%E8%AE%A1" target="_blank" rel="external">hexo/next 添加 Google/百度 统计</a></h3><p><a href="https://www.google.com/analytics/" target="_blank" rel="external">Google Analytics（分析）</a> 不仅可以帮助您衡量销售与转化情况，而且能为您提供新鲜的深入信息，帮助您了解访问者如何使用您的网站，他们如何到达您的网站，以及您可以如何吸引他们不断回访。</p>
<p><a href="http://tongji.baidu.com/" target="_blank" rel="external">百度统计</a> 是百度推出的一款免费的专业网站流量分析工具，能够告诉用户访客是如何找到并浏览用户的网站，在网站上做了些什么，有了这些信息，可以帮助用户改善访客在用户的网站上的使用体验，不断提升网站的投资回报率。</p>
<p>到 Google 或 Baidu 的统计分析门户注册自己的站点，将获得统计分析平台为你的站点分配的唯一的网站统计 ID 。</p>
<p>编辑主题配置文件，新增 google_analytics 或 baidu_analytics 字段（取决于使用的统计系统），其值为申请到的统计 ID，即可将自己的站点接入 Google / Baidu 的统计分析平台：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">google_analytics: your-analytics-id&#10;baidu_analytics: your-analytics-id</span><br></pre></td></tr></table></figure>
<p>下面基于 hexo/next 博客，阐述如何接入腾讯统计分析。</p>
<h3 id="hexo/next_添加_腾讯分析">hexo/next 添加 腾讯分析</h3><h4 id="为自己的站点申请腾讯分析_ID">为自己的站点申请腾讯分析 ID</h4><p>1.进入 <a href="http://v2.ta.qq.com/analysis/index" target="_blank" rel="external">腾讯分析首页</a>，使用 QQ 账号登陆。<br>2.登录后，进入 <a href="http://v2.ta.qq.com/bind/site" target="_blank" rel="external">腾讯分析欢迎页</a> ，提示“您还没有注册站点，请先添加您的站点”，需要在编辑框中输入域名或二级域名，这里添加 <code>col.dog</code>。<br>3.请将下列代码添加至网站代码 <code>&lt;/body&gt;</code> 前（参见下一节的安装说明）。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span> <span class="attribute">src</span>=<span class="value">"http://tajs.qq.com/stats?sId=$your_ta_sid"</span> <span class="attribute">charset</span>=<span class="value">"UTF-8"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>$your_ta_sid</code> 为腾讯分析为你注册的网站分配的 ID。</p>
<p><strong>注意：</strong></p>
<blockquote>
<p>框架式网站请在框架集页面和子框架页面均安装统计代码，框架集页面请安装在 <code>&lt;/head&gt;</code> 前。</p>
</blockquote>
<h4 id="将自己的站点接入腾讯分析">将自己的站点接入腾讯分析</h4><p>1.在目录 <code>/themes/next/layout/_scripts/analytics/</code> 下新建 <code>tencent-analytics.swig</code> 文件，基于 <code>baidu-analytics.swig</code> 略作修改：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.tencent_analytics %&#125;&#10;  &#60;script type=&#34;text/javascript&#34;&#62;&#10;    var _hmt = _hmt || [];&#10;    (function() &#123;&#10;      var hm = document.createElement(&#34;script&#34;);&#10;      hm.src = &#34;//tajs.qq.com/stats?sId=&#123;&#123; theme.tencent_analytics &#125;&#125;&#34;;&#10;      var s = document.getElementsByTagName(&#34;script&#34;)[0];&#10;      s.parentNode.insertBefore(hm, s);&#10;    &#125;)();&#10;  &#60;/script&#62;&#10;&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码的意思是，如果 theme 配置了 <code>tencent_analytics</code> ID，则添加腾讯分析的 <code>&lt;script&gt;</code> 统计代码。</p>
<p>2.打开 <code>/themes/next/layout/_scripts/analytics.swig</code> 文件，在末尾添加包含 <code>tencent-analytics.swig</code> 文件：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;% include &#39;analytics/tencent-analytics.swig&#39; %&#125;</span><br></pre></td></tr></table></figure>
<p>3.打开主题配置文件，新增配置字段 <code>tencent_analytics</code>，设置其值为 <code>your_ta_sid</code>。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">tencent_analytics: $your_ta_sid</span><br></pre></td></tr></table></figure>
<p>4.重新生成部署网站，则可接入腾讯分析。</p>
<p>在 腾讯分析 网站的个人站点列表中可以浏览网站概况，其中列出了 <strong>今日浏览量（PV）</strong>、<strong>今日独立 IP</strong>、<strong>今日用户量（UV）</strong> 等统计分析指标。</p>
<h2 id="提交搜索引擎收录（SiteMap）">提交搜索引擎收录（SiteMap）</h2><p>站点地图（SiteMap）有助于搜索引擎更好地决定如何抓取您的网站，进而提高博客站点在搜索结果中的曝光率，从而<a href="http://aaronyee.com/blog/2015/06/14/blog-open.html" target="_blank" rel="external">促进博客的分享推广</a>。</p>
<p>1.在命令行终端中，通过 npm 来安装 <a href="https://github.com/hexojs/hexo-generator-sitemap" target="_blank" rel="external">hexo-generator-sitemap</a> 插件：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#10140;  github-pages git:(master) &#10007; npm install hexo-generator-sitemap --save&#10;hexo-generator-sitemap@1.0.1 node_modules/hexo-generator-sitemap&#10;&#9500;&#9472;&#9472; utils-merge@1.0.0&#10;&#9492;&#9472;&#9472; ejs@1.0.0</span><br></pre></td></tr></table></figure>
<p>2.在站点配置文件中加载 hexo-generator-sitemap 插件：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Plugins:&#10;- hexo-generator-sitemap</span><br></pre></td></tr></table></figure>
<p>3.在站点配置文件中设置 sitemap 的路径（path）为 sitemap.xml：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#sitemap&#10;sitemap:&#10;  path: sitemap.xml</span><br></pre></td></tr></table></figure>
<p>重新编译网站，将在 <code>public</code> 目录下生成 <code>sitemap.xml</code> 文件。</p>
<p>使用 Google/Gmail 账号登录 <a href="https://www.google.com/webmasters/tools/home?hl=zh-CN" target="_blank" rel="external">Google Search Console</a> ，注册自己的站点，验证身份（google_site_verification）后，可以指定博客站点的地图文件（/sitemap.xml）。之后，Google 搜索引擎会自动定时获取站点最新的 sitemap.xml 文件。</p>
<h2 id="参考">参考</h2><p><a href="http://ibruce.info/2013/11/22/hexo-your-blog/" target="_blank" rel="external">hexo 你的博客</a> —— ibruce<br><a href="http://ijiaober.github.io/categories/hexo/" target="_blank" rel="external">Hexo 系列攻略</a> —— ijiaober<br><a href="http://zipperary.com/categories/hexo/" target="_blank" rel="external">Hexo 系列教程</a> —— zipperary<br><a href="http://crazykay.github.io/categories/hexo/" target="_blank" rel="external">Hexo 系列教程</a> —— crazykay</p>
<p><a href="http://cnfeat.com/blog/2014/05/10/how-to-build-a-blog/" target="_blank" rel="external">Hexo github 独立博客</a><br><a href="http://blog.csdn.net/renfufei/article/details/37725057/" target="_blank" rel="external">创建GitHub技术博客全攻略</a></p>
<p><a href="http://andy-yao.me/2015/05/06/blog-with-hexo/" target="_blank" rel="external">用 HEXO 搭建个人博客</a><br><a href="http://blog.newbmiao.com/2015/06/16/hexo-on-your-github.html" target="_blank" rel="external">搭建你自己的 Hexo 博客</a><br><a href="http://blog.csdn.net/poem_of_sunshine/article/details/29369785/" target="_blank" rel="external">简明 Github Pages 与 Hexo 教程</a></p>
<p><a href="http://segmentfault.com/a/1190000002592993" target="_blank" rel="external">Hexo 3.0 静态博客使用指南</a><br><a href="http://www.cnblogs.com/zhcncn/p/4097881.html" target="_blank" rel="external">Hexo 搭建 Github 静态博客</a><br><a href="http://www.freehao123.com/hexo-node-js/" target="_blank" rel="external">Hexo 免费静态博客安装和使用方法</a><br><a href="http://blog.fens.me/hexo-blog-github/" target="_blank" rel="external">Hexo 在 github 上构建免费的 Web 应用</a></p>
<p><a href="http://www.voidking.com/2015/05/31/deve-hexo-theme-optimize/" target="_blank" rel="external">hexo 主题优化</a><br><a href="http://www.bubuko.com/infodetail-618287.html" target="_blank" rel="external">Hexo 博客优化</a><br><a href="http://blog.sunnyxx.com/2014/03/07/hexo_customize/" target="_blank" rel="external">hexo 的私人订制</a><br><a href="http://lukang.me/categories/Hexo/" target="_blank" rel="external">Hexo 优化与定制</a></p>
<p><a href="http://bubkoo.com/2013/12/16/hexo-issure/" target="_blank" rel="external">关于 Hexo 的若干问题</a><br><a href="https://xuanwo.org/2014/08/14/hexo-usual-problem/#Hexo3-0%E4%BB%A5%E4%B8%8A%E6%94%AF%E6%8C%81" target="_blank" rel="external">Hexo常见问题解决方案</a></p>
<h2 id="<!-以下是本文的脚注和超链接->"><!--以下是本文的脚注和超链接--></h2><!-- ## 安装 Node.js + NPM -->
<!-- ## hexo init -->
<!-- ## hexo generate -->
<!-- ## hexo deploy -->
<!-- ## 图片存储 -->
<!-- ## 404 -->
<!-- ## 配置主题 -->
<!-- ## 添加多说评论 -->
<!-- ## 添加 RSS/Feed -->
<!-- ## 添加统计分析 -->
<!-- ## 提交搜索引擎收录 -->
]]></content>
    <summary type="html">
    <![CDATA[<p>本文详细记录了从安装 node.js / Hexo 到 使用 hexo 发布 markdown 格式的博客并托管到 GitHub 的全过程。</p>]]>
    
    </summary>
    
      <category term="analytics" scheme="http://col.dog/tags/analytics/"/>
    
      <category term="feed" scheme="http://col.dog/tags/feed/"/>
    
      <category term="hexo" scheme="http://col.dog/tags/hexo/"/>
    
      <category term="next" scheme="http://col.dog/tags/next/"/>
    
      <category term="node.js" scheme="http://col.dog/tags/node-js/"/>
    
      <category term="npm" scheme="http://col.dog/tags/npm/"/>
    
      <category term="sitemap" scheme="http://col.dog/tags/sitemap/"/>
    
      <category term="Hexo" scheme="http://col.dog/categories/Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[坳口]]></title>
    <link href="http://col.dog/2015/11/08/col/"/>
    <id>http://col.dog/2015/11/08/col/</id>
    <published>2015-11-08T12:04:46.000Z</published>
    <updated>2015-11-13T00:10:12.000Z</updated>
    <content type="html"><![CDATA[<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">col 英[kɒ<span class="keyword">l</span>] 美[kɑ:<span class="keyword">l</span>]</span><br><span class="line"><span class="keyword">n</span>.	坳; 山口; 关口，峡路，关隘; 山坞;</span><br></pre></td></tr></table></figure>
<p><img src="http://7xo5uz.com1.z0.glb.clouddn.com/coltree.jpg" alt="一棵被遗弃在坳口上的树"></p>
<a id="more"></a>
<p>记忆中的坳口<br>风总是很大<br>翻过坳口<br>就是我们的家</p>
<p>站在坳口<br>能眺望远方的世界<br>能望见田野的油菜花<br>那袅袅升起的炊烟<br>不知是哪家厨房里<br>正在忙碌的妈妈</p>
<p>翻山越岭到坳口<br>熄灭咆哮一路的汽车火花<br>欢快的车轱辘一路空档向下<br>满载一路的团圆梦<br>驶向温暖的家</p>
<p>汽车开出了坳口<br>我们便在路上向别处奋发<br>回去吧爸爸妈妈<br>寒来暑往中<br>我们渐渐长大</p>
<p>而如今<br>在那迎来送往的坳口<br>葬着我的爸爸<br>只有那棵二叉香樟树<br>和那春风吹又生的野草<br>日夜陪伴着他</p>
<hr>

<p>– 2012.12</p>
]]></content>
    <summary type="html">
    <![CDATA[<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">col 英[kɒ<span class="keyword">l</span>] 美[kɑ:<span class="keyword">l</span>]</span><br><span class="line"><span class="keyword">n</span>.	坳; 山口; 关口，峡路，关隘; 山坞;</span><br></pre></td></tr></table></figure>
<p><img src="http://7xo5uz.com1.z0.glb.clouddn.com/coltree.jpg" alt="一棵被遗弃在坳口上的树"></p>]]>
    
    </summary>
    
      <category term="坳口" scheme="http://col.dog/tags/%E5%9D%B3%E5%8F%A3/"/>
    
      <category term="故乡" scheme="http://col.dog/categories/%E6%95%85%E4%B9%A1/"/>
    
  </entry>
  
</feed>
